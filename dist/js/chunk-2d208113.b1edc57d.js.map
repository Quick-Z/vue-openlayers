{"version":3,"sources":["webpack:///./node_modules/ol/geom/GeometryCollection.js","webpack:///./node_modules/ol/format/Feature.js","webpack:///./node_modules/ol/format/JSONFeature.js","webpack:///./node_modules/ol/format/GeoJSON.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","TypeError","String","__","this","constructor","create","_super","GeometryCollection","opt_geometries","_this","geometries_","changeEventsKeys_","listenGeometriesChange_","unlistenGeometriesChange_","forEach","length","i","ii","push","EventType","CHANGE","changed","clone","geometryCollection","setGeometries","applyProperties","closestPointXY","x","y","closestPoint","minSquaredDistance","getExtent","geometries","containsXY","computeExtent","extent","getGeometries","cloneGeometries","getGeometriesArray","getGeometriesArrayRecursive","geometriesArray","getType","concat","getSimplifiedGeometry","squaredTolerance","simplifiedGeometryRevision","getRevision","simplifiedGeometryMaxMinSquaredTolerance","simplifiedGeometries","simplified","geometry","simplifiedGeometry","simplifiedGeometryCollection","setGeometriesArray","GeometryType","GEOMETRY_COLLECTION","intersectsExtent","isEmpty","rotate","angle","anchor","scale","sx","opt_sy","opt_anchor","applyTransform","transformFn","translate","deltaX","deltaY","disposeInternal","Geometry","clonedGeometries","FeatureFormat","dataProjection","undefined","defaultFeatureProjection","supportedMediaTypes","getReadOptions","source","opt_options","options","readProjection","getUnits","Units","TILE_PIXELS","setWorldExtent","featureProjection","adaptOptions","readFeature","readFeatures","readGeometry","writeFeature","feature","writeFeatures","features","writeGeometry","transformGeometryWithOptions","write","transformed","transform","decimals","power_1","Math","pow","coordinates","round","JSONFeature","FormatType","JSON","readFeatureFromObject","getObject","readFeaturesFromObject","object","readGeometryFromObject","readProjectionFromObject","stringify","writeFeatureObject","writeFeaturesObject","writeGeometryObject","parse","GeoJSON","geometryName_","geometryName","extractGeometryName_","extractGeometryName","geoJSONFeature","Feature","setGeometryName","setGeometry","setId","setProperties","geoJSONObject","geoJSONFeatureCollection","geoJSONFeatures","projection","crs","properties","id","getId","hasProperties","getProperties","getGeometry","getGeometryName","objects","type","POINT","readPointGeometry","LINE_STRING","readLineStringGeometry","POLYGON","readPolygonGeometry","MULTI_POINT","readMultiPointGeometry","MULTI_LINE_STRING","readMultiLineStringGeometry","MULTI_POLYGON","readMultiPolygonGeometry","readGeometryCollectionGeometry","Error","map","Point","LineString","MultiLineString","MultiPoint","MultiPolygon","Polygon","geoJSON","writePointGeometry","writeLineStringGeometry","writePolygonGeometry","writeMultiPointGeometry","writeMultiLineStringGeometry","writeMultiPolygonGeometry","writeGeometryCollectionGeometry","CIRCLE","getCoordinates","right","rightHanded"],"mappings":"4LAAIA,EAAwC,WACxC,IAAIC,EAAgB,SAAUC,EAAGC,GAI7B,OAHAF,EAAgBG,OAAOC,gBAClB,CAAEC,UAAW,cAAgBC,OAAS,SAAUL,EAAGC,GAAKD,EAAEI,UAAYH,IACvE,SAAUD,EAAGC,GAAK,IAAK,IAAIK,KAAKL,EAAOC,OAAOK,UAAUC,eAAeC,KAAKR,EAAGK,KAAIN,EAAEM,GAAKL,EAAEK,KACzFP,EAAcC,EAAGC,IAE5B,OAAO,SAAUD,EAAGC,GAChB,GAAiB,oBAANA,GAA0B,OAANA,EAC3B,MAAM,IAAIS,UAAU,uBAAyBC,OAAOV,GAAK,iCAE7D,SAASW,IAAOC,KAAKC,YAAcd,EADnCD,EAAcC,EAAGC,GAEjBD,EAAEO,UAAkB,OAANN,EAAaC,OAAOa,OAAOd,IAAMW,EAAGL,UAAYN,EAAEM,UAAW,IAAIK,IAZ3C,GA6BxC,EAAoC,SAAUI,GAK9C,SAASC,EAAmBC,GACxB,IAAIC,EAAQH,EAAOP,KAAKI,OAASA,KAWjC,OANAM,EAAMC,YAAcF,GAAkC,KAItDC,EAAME,kBAAoB,GAC1BF,EAAMG,0BACCH,EAqQX,OArRArB,EAAUmB,EAAoBD,GAqB9BC,EAAmBV,UAAUgB,0BAA4B,WACrDV,KAAKQ,kBAAkBG,QAAQ,QAC/BX,KAAKQ,kBAAkBI,OAAS,GAKpCR,EAAmBV,UAAUe,wBAA0B,WACnD,GAAKT,KAAKO,YAGV,IAAK,IAAIM,EAAI,EAAGC,EAAKd,KAAKO,YAAYK,OAAQC,EAAIC,IAAMD,EACpDb,KAAKQ,kBAAkBO,KAAK,eAAOf,KAAKO,YAAYM,GAAIG,EAAA,KAAUC,OAAQjB,KAAKkB,QAASlB,QAQhGI,EAAmBV,UAAUyB,MAAQ,WACjC,IAAIC,EAAqB,IAAIhB,EAAmB,MAGhD,OAFAgB,EAAmBC,cAAcrB,KAAKO,aACtCa,EAAmBE,gBAAgBtB,MAC5BoB,GASXhB,EAAmBV,UAAU6B,eAAiB,SAAUC,EAAGC,EAAGC,EAAcC,GACxE,GAAIA,EAAqB,eAAyB3B,KAAK4B,YAAaJ,EAAGC,GACnE,OAAOE,EAGX,IADA,IAAIE,EAAa7B,KAAKO,YACbM,EAAI,EAAGC,EAAKe,EAAWjB,OAAQC,EAAIC,IAAMD,EAC9Cc,EAAqBE,EAAWhB,GAAGU,eAAeC,EAAGC,EAAGC,EAAcC,GAE1E,OAAOA,GAOXvB,EAAmBV,UAAUoC,WAAa,SAAUN,EAAGC,GAEnD,IADA,IAAII,EAAa7B,KAAKO,YACbM,EAAI,EAAGC,EAAKe,EAAWjB,OAAQC,EAAIC,IAAMD,EAC9C,GAAIgB,EAAWhB,GAAGiB,WAAWN,EAAGC,GAC5B,OAAO,EAGf,OAAO,GAOXrB,EAAmBV,UAAUqC,cAAgB,SAAUC,GACnD,eAAoBA,GAEpB,IADA,IAAIH,EAAa7B,KAAKO,YACbM,EAAI,EAAGC,EAAKe,EAAWjB,OAAQC,EAAIC,IAAMD,EAC9C,eAAOmB,EAAQH,EAAWhB,GAAGe,aAEjC,OAAOI,GAOX5B,EAAmBV,UAAUuC,cAAgB,WACzC,OAAOC,EAAgBlC,KAAKO,cAKhCH,EAAmBV,UAAUyC,mBAAqB,WAC9C,OAAOnC,KAAKO,aAKhBH,EAAmBV,UAAU0C,4BAA8B,WAIvD,IAFA,IAAIC,EAAkB,GAClBR,EAAa7B,KAAKO,YACbM,EAAI,EAAGC,EAAKe,EAAWjB,OAAQC,EAAIC,IAAMD,EAC1CgB,EAAWhB,GAAGyB,YAActC,KAAKsC,UACjCD,EAAkBA,EAAgBE,OACCV,EAAWhB,GAAIuB,+BAGlDC,EAAgBtB,KAAKc,EAAWhB,IAGxC,OAAOwB,GAOXjC,EAAmBV,UAAU8C,sBAAwB,SAAUC,GAK3D,GAJIzC,KAAK0C,6BAA+B1C,KAAK2C,gBACzC3C,KAAK4C,yCAA2C,EAChD5C,KAAK0C,2BAA6B1C,KAAK2C,eAEvCF,EAAmB,GACgC,IAAlDzC,KAAK4C,0CACFH,EAAmBzC,KAAK4C,yCAC5B,OAAO5C,KAKX,IAHA,IAAI6C,EAAuB,GACvBhB,EAAa7B,KAAKO,YAClBuC,GAAa,EACRjC,EAAI,EAAGC,EAAKe,EAAWjB,OAAQC,EAAIC,IAAMD,EAAG,CACjD,IAAIkC,EAAWlB,EAAWhB,GACtBmC,EAAqBD,EAASP,sBAAsBC,GACxDI,EAAqB9B,KAAKiC,GACtBA,IAAuBD,IACvBD,GAAa,GAGrB,GAAIA,EAAY,CACZ,IAAIG,EAA+B,IAAI7C,EAAmB,MAE1D,OADA6C,EAA6BC,mBAAmBL,GACzCI,EAIP,OADAjD,KAAK4C,yCAA2CH,EACzCzC,MAQfI,EAAmBV,UAAU4C,QAAU,WACnC,OAAOa,EAAA,KAAaC,qBAQxBhD,EAAmBV,UAAU2D,iBAAmB,SAAUrB,GAEtD,IADA,IAAIH,EAAa7B,KAAKO,YACbM,EAAI,EAAGC,EAAKe,EAAWjB,OAAQC,EAAIC,IAAMD,EAC9C,GAAIgB,EAAWhB,GAAGwC,iBAAiBrB,GAC/B,OAAO,EAGf,OAAO,GAKX5B,EAAmBV,UAAU4D,QAAU,WACnC,OAAmC,IAA5BtD,KAAKO,YAAYK,QAS5BR,EAAmBV,UAAU6D,OAAS,SAAUC,EAAOC,GAEnD,IADA,IAAI5B,EAAa7B,KAAKO,YACbM,EAAI,EAAGC,EAAKe,EAAWjB,OAAQC,EAAIC,IAAMD,EAC9CgB,EAAWhB,GAAG0C,OAAOC,EAAOC,GAEhCzD,KAAKkB,WAYTd,EAAmBV,UAAUgE,MAAQ,SAAUC,EAAIC,EAAQC,GACvD,IAAIJ,EAASI,EACRJ,IACDA,EAAS,eAAUzD,KAAK4B,cAG5B,IADA,IAAIC,EAAa7B,KAAKO,YACbM,EAAI,EAAGC,EAAKe,EAAWjB,OAAQC,EAAIC,IAAMD,EAC9CgB,EAAWhB,GAAG6C,MAAMC,EAAIC,EAAQH,GAEpCzD,KAAKkB,WAOTd,EAAmBV,UAAU2B,cAAgB,SAAUQ,GACnD7B,KAAKkD,mBAAmBhB,EAAgBL,KAK5CzB,EAAmBV,UAAUwD,mBAAqB,SAAUrB,GACxD7B,KAAKU,4BACLV,KAAKO,YAAcsB,EACnB7B,KAAKS,0BACLT,KAAKkB,WAWTd,EAAmBV,UAAUoE,eAAiB,SAAUC,GAEpD,IADA,IAAIlC,EAAa7B,KAAKO,YACbM,EAAI,EAAGC,EAAKe,EAAWjB,OAAQC,EAAIC,IAAMD,EAC9CgB,EAAWhB,GAAGiD,eAAeC,GAEjC/D,KAAKkB,WASTd,EAAmBV,UAAUsE,UAAY,SAAUC,EAAQC,GAEvD,IADA,IAAIrC,EAAa7B,KAAKO,YACbM,EAAI,EAAGC,EAAKe,EAAWjB,OAAQC,EAAIC,IAAMD,EAC9CgB,EAAWhB,GAAGmD,UAAUC,EAAQC,GAEpClE,KAAKkB,WAKTd,EAAmBV,UAAUyE,gBAAkB,WAC3CnE,KAAKU,4BACLP,EAAOT,UAAUyE,gBAAgBvE,KAAKI,OAEnCI,EAtR4B,CAuRrCgE,EAAA,MAKF,SAASlC,EAAgBL,GAErB,IADA,IAAIwC,EAAmB,GACdxD,EAAI,EAAGC,EAAKe,EAAWjB,OAAQC,EAAIC,IAAMD,EAC9CwD,EAAiBtD,KAAKc,EAAWhB,GAAGM,SAExC,OAAOkD,EAEI,Q,gDCtQX,EAA+B,WAC/B,SAASC,IAKLtE,KAAKuE,oBAAiBC,EAKtBxE,KAAKyE,8BAA2BD,EAKhCxE,KAAK0E,oBAAsB,KA8H/B,OArHAJ,EAAc5E,UAAUiF,eAAiB,SAAUC,EAAQC,GACvD,IAAIC,EACJ,GAAID,EAAa,CACb,IAAIN,EAAiBM,EAAYN,eAC3B,eAAcM,EAAYN,gBAC1BvE,KAAK+E,eAAeH,GACtBC,EAAY7C,QACZuC,GACAA,EAAeS,aAAeC,EAAA,KAAMC,cACpCX,EAAiB,eAAcA,GAC/BA,EAAeY,eAAeN,EAAY7C,SAE9C8C,EAAU,CACNP,eAAgBA,EAChBa,kBAAmBP,EAAYO,mBAGvC,OAAOpF,KAAKqF,aAAaP,IAW7BR,EAAc5E,UAAU2F,aAAe,SAAUP,GAC7C,OAAO,eAAO,CACVP,eAAgBvE,KAAKuE,eACrBa,kBAAmBpF,KAAKyE,0BACzBK,IAMPR,EAAc5E,UAAU4C,QAAU,WAC9B,OAAO,kBAUXgC,EAAc5E,UAAU4F,YAAc,SAAUV,EAAQC,GACpD,OAAO,kBAUXP,EAAc5E,UAAU6F,aAAe,SAAUX,EAAQC,GACrD,OAAO,kBAUXP,EAAc5E,UAAU8F,aAAe,SAAUZ,EAAQC,GACrD,OAAO,kBASXP,EAAc5E,UAAUqF,eAAiB,SAAUH,GAC/C,OAAO,kBAUXN,EAAc5E,UAAU+F,aAAe,SAAUC,EAASb,GACtD,OAAO,kBAUXP,EAAc5E,UAAUiG,cAAgB,SAAUC,EAAUf,GACxD,OAAO,kBAUXP,EAAc5E,UAAUmG,cAAgB,SAAU9C,EAAU8B,GACxD,OAAO,kBAEJP,EA9IuB,GAgJnB,IAOR,SAASwB,EAA6B/C,EAAUgD,EAAOlB,GAC1D,IAMImB,EANAZ,EAAoBP,EAClB,eAAcA,EAAYO,mBAC1B,KACFb,EAAiBM,EACf,eAAcA,EAAYN,gBAC1B,KAUN,GALIyB,EAHAZ,GACAb,IACC,eAAqBa,EAAmBb,IAC1BwB,EAAQhD,EAAS5B,QAAU4B,GAAUkD,UAAUF,EAAQX,EAAoBb,EAAgBwB,EAAQxB,EAAiBa,GAGrHrC,EAEdgD,GACAlB,QACuDL,IAA3B,EAAc0B,SAAwB,CAClE,IAAIC,EAAUC,KAAKC,IAAI,GACK,EAAcH,UAMtCD,EAAY,SAAUK,GACtB,IAAK,IAAIzF,EAAI,EAAGC,EAAKwF,EAAY1F,OAAQC,EAAIC,IAAMD,EAC/CyF,EAAYzF,GAAKuF,KAAKG,MAAMD,EAAYzF,GAAKsF,GAAWA,EAE5D,OAAOG,GAEPN,IAAgBjD,IAChBiD,EAAcjD,EAAS5B,SAE3B6E,EAAYlC,eAAemC,GAE/B,OAAOD,E,gBCtPP,EAAwC,WACxC,IAAI9G,EAAgB,SAAUC,EAAGC,GAI7B,OAHAF,EAAgBG,OAAOC,gBAClB,CAAEC,UAAW,cAAgBC,OAAS,SAAUL,EAAGC,GAAKD,EAAEI,UAAYH,IACvE,SAAUD,EAAGC,GAAK,IAAK,IAAIK,KAAKL,EAAOC,OAAOK,UAAUC,eAAeC,KAAKR,EAAGK,KAAIN,EAAEM,GAAKL,EAAEK,KACzFP,EAAcC,EAAGC,IAE5B,OAAO,SAAUD,EAAGC,GAChB,GAAiB,oBAANA,GAA0B,OAANA,EAC3B,MAAM,IAAIS,UAAU,uBAAyBC,OAAOV,GAAK,iCAE7D,SAASW,IAAOC,KAAKC,YAAcd,EADnCD,EAAcC,EAAGC,GAEjBD,EAAEO,UAAkB,OAANN,EAAaC,OAAOa,OAAOd,IAAMW,EAAGL,UAAYN,EAAEM,UAAW,IAAIK,IAZ3C,GA6BxC,EAA6B,SAAUI,GAEvC,SAASqG,IACL,OAAOrG,EAAOP,KAAKI,OAASA,KAwJhC,OA1JA,EAAUwG,EAAarG,GAOvBqG,EAAY9G,UAAU4C,QAAU,WAC5B,OAAOmE,EAAA,KAAWC,MAWtBF,EAAY9G,UAAU4F,YAAc,SAAUV,EAAQC,GAClD,OAAO7E,KAAK2G,sBAAsBC,EAAUhC,GAAS5E,KAAK2E,eAAeC,EAAQC,KAWrF2B,EAAY9G,UAAU6F,aAAe,SAAUX,EAAQC,GACnD,OAAO7E,KAAK6G,uBAAuBD,EAAUhC,GAAS5E,KAAK2E,eAAeC,EAAQC,KAStF2B,EAAY9G,UAAUiH,sBAAwB,SAAUG,EAAQjC,GAC5D,OAAO,kBASX2B,EAAY9G,UAAUmH,uBAAyB,SAAUC,EAAQjC,GAC7D,OAAO,kBAUX2B,EAAY9G,UAAU8F,aAAe,SAAUZ,EAAQC,GACnD,OAAO7E,KAAK+G,uBAAuBH,EAAUhC,GAAS5E,KAAK2E,eAAeC,EAAQC,KAStF2B,EAAY9G,UAAUqH,uBAAyB,SAAUD,EAAQjC,GAC7D,OAAO,kBASX2B,EAAY9G,UAAUqF,eAAiB,SAAUH,GAC7C,OAAO5E,KAAKgH,yBAAyBJ,EAAUhC,KAQnD4B,EAAY9G,UAAUsH,yBAA2B,SAAUF,GACvD,OAAO,kBAUXN,EAAY9G,UAAU+F,aAAe,SAAUC,EAASb,GACpD,OAAO6B,KAAKO,UAAUjH,KAAKkH,mBAAmBxB,EAASb,KAQ3D2B,EAAY9G,UAAUwH,mBAAqB,SAAUxB,EAASb,GAC1D,OAAO,kBAUX2B,EAAY9G,UAAUiG,cAAgB,SAAUC,EAAUf,GACtD,OAAO6B,KAAKO,UAAUjH,KAAKmH,oBAAoBvB,EAAUf,KAQ7D2B,EAAY9G,UAAUyH,oBAAsB,SAAUvB,EAAUf,GAC5D,OAAO,kBAUX2B,EAAY9G,UAAUmG,cAAgB,SAAU9C,EAAU8B,GACtD,OAAO6B,KAAKO,UAAUjH,KAAKoH,oBAAoBrE,EAAU8B,KAQ7D2B,EAAY9G,UAAU0H,oBAAsB,SAAUrE,EAAU8B,GAC5D,OAAO,kBAEJ2B,EA3JqB,CA4J9B,GAKF,SAASI,EAAUhC,GACf,GAAsB,kBAAXA,EAAqB,CAC5B,IAAIkC,EAASJ,KAAKW,MAAMzC,GACxB,OAAOkC,GAA0C,KAEhD,OAAe,OAAXlC,EACEA,EAGA,KAGA,Q,oFCvMX,EAAwC,WACxC,IAAI1F,EAAgB,SAAUC,EAAGC,GAI7B,OAHAF,EAAgBG,OAAOC,gBAClB,CAAEC,UAAW,cAAgBC,OAAS,SAAUL,EAAGC,GAAKD,EAAEI,UAAYH,IACvE,SAAUD,EAAGC,GAAK,IAAK,IAAIK,KAAKL,EAAOC,OAAOK,UAAUC,eAAeC,KAAKR,EAAGK,KAAIN,EAAEM,GAAKL,EAAEK,KACzFP,EAAcC,EAAGC,IAE5B,OAAO,SAAUD,EAAGC,GAChB,GAAiB,oBAANA,GAA0B,OAANA,EAC3B,MAAM,IAAIS,UAAU,uBAAyBC,OAAOV,GAAK,iCAE7D,SAASW,IAAOC,KAAKC,YAAcd,EADnCD,EAAcC,EAAGC,GAEjBD,EAAEO,UAAkB,OAANN,EAAaC,OAAOa,OAAOd,IAAMW,EAAGL,UAAYN,EAAEM,UAAW,IAAIK,IAZ3C,GA2DxC,EAAyB,SAAUI,GAKnC,SAASmH,EAAQzC,GACb,IAAIvE,EAAQN,KACR8E,EAAUD,GAA4B,GAyB1C,OAxBAvE,EAAQH,EAAOP,KAAKI,OAASA,KAI7BM,EAAMiE,eAAiB,eAAcO,EAAQP,eAAiBO,EAAQP,eAAiB,aACnFO,EAAQM,oBACR9E,EAAMmE,yBAA2B,eAAcK,EAAQM,oBAO3D9E,EAAMiH,cAAgBzC,EAAQ0C,aAM9BlH,EAAMmH,qBAAuB3C,EAAQ4C,oBACrCpH,EAAMoE,oBAAsB,CACxB,uBACA,4BAEGpE,EAiKX,OAhMA,EAAUgH,EAASnH,GAuCnBmH,EAAQ5H,UAAUiH,sBAAwB,SAAUG,EAAQjC,GAIxD,IAAI8C,EAAiB,KAEjBA,EADmB,YAAnBb,EAAO,QACwC,EAG9B,CACb,KAAQ,UACR,SAA2C,EAC3C,WAAc,MAGtB,IAAI/D,EAAWyC,EAAamC,EAAe,YAAa9C,GACpDa,EAAU,IAAIkC,EAAA,KAelB,OAdI5H,KAAKuH,cACL7B,EAAQmC,gBAAgB7H,KAAKuH,eAExBvH,KAAKyH,sBACV,kBAAmBE,SAAmBnD,GACtCkB,EAAQmC,gBAAgBF,EAAe,kBAE3CjC,EAAQoC,YAAY/E,GAChB,OAAQ4E,GACRjC,EAAQqC,MAAMJ,EAAe,OAE7BA,EAAe,eACfjC,EAAQsC,cAAcL,EAAe,eAAe,GAEjDjC,GAQX4B,EAAQ5H,UAAUmH,uBAAyB,SAAUC,EAAQjC,GACzD,IAAIoD,EAA6C,EAE7CrC,EAAW,KACf,GAA8B,sBAA1BqC,EAAc,QAAiC,CAC/C,IAAIC,EAAmE,EACvEtC,EAAW,GAEX,IADA,IAAIuC,EAAkBD,EAAyB,YACtCrH,EAAI,EAAGC,EAAKqH,EAAgBvH,OAAQC,EAAIC,IAAMD,EACnD+E,EAAS7E,KAAKf,KAAK2G,sBAAsBwB,EAAgBtH,GAAIgE,SAIjEe,EAAW,CAAC5F,KAAK2G,sBAAsBG,EAAQjC,IAEnD,OAAOe,GAQX0B,EAAQ5H,UAAUqH,uBAAyB,SAAUD,EAAQjC,GACzD,OAAOW,EAAasB,EAAQjC,IAOhCyC,EAAQ5H,UAAUsH,yBAA2B,SAAUF,GACnD,IACIsB,EADAC,EAAMvB,EAAO,OAgBjB,OAdIuB,EACmB,QAAfA,EAAI,QACJD,EAAa,eAAcC,EAAI,cAAc,SAExB,SAAhBA,EAAI,QACTD,EAAa,eAAc,QAAUC,EAAI,cAAc,SAGvD,gBAAO,EAAO,IAIlBD,EAAapI,KAAKuE,eAEwC,GAUlE+C,EAAQ5H,UAAUwH,mBAAqB,SAAUxB,EAASb,GACtDA,EAAc7E,KAAKqF,aAAaR,GAEhC,IAAIiC,EAAS,CACT,KAAQ,UACR/D,SAAU,KACVuF,WAAY,MAEZC,EAAK7C,EAAQ8C,QAIjB,QAHWhE,IAAP+D,IACAzB,EAAOyB,GAAKA,IAEX7C,EAAQ+C,gBACT,OAAO3B,EAEX,IAAIwB,EAAa5C,EAAQgD,gBACrB3F,EAAW2C,EAAQiD,cAQvB,OAPI5F,IACA+D,EAAO/D,SAAW8C,EAAc9C,EAAU8B,UACnCyD,EAAW5C,EAAQkD,oBAEzB,eAAQN,KACTxB,EAAOwB,WAAaA,GAEjBxB,GAUXQ,EAAQ5H,UAAUyH,oBAAsB,SAAUvB,EAAUf,GACxDA,EAAc7E,KAAKqF,aAAaR,GAEhC,IADA,IAAIgE,EAAU,GACLhI,EAAI,EAAGC,EAAK8E,EAAShF,OAAQC,EAAIC,IAAMD,EAC5CgI,EAAQ9H,KAAKf,KAAKkH,mBAAmBtB,EAAS/E,GAAIgE,IAEtD,MAAO,CACHiE,KAAM,oBACNlD,SAAUiD,IAWlBvB,EAAQ5H,UAAU0H,oBAAsB,SAAUrE,EAAU8B,GACxD,OAAOgB,EAAc9C,EAAU/C,KAAKqF,aAAaR,KAE9CyC,EAjMiB,CAkM1B,GAMF,SAAS9B,EAAasB,EAAQjC,GAC1B,IAAKiC,EACD,OAAO,KAKX,IAAI/D,EACJ,OAAQ+D,EAAO,SACX,KAAK3D,EAAA,KAAa4F,MACdhG,EAAWiG,EAA8C,GACzD,MAEJ,KAAK7F,EAAA,KAAa8F,YACdlG,EAAWmG,EACsB,GACjC,MAEJ,KAAK/F,EAAA,KAAagG,QACdpG,EAAWqG,EAAkD,GAC7D,MAEJ,KAAKjG,EAAA,KAAakG,YACdtG,EAAWuG,EACsB,GACjC,MAEJ,KAAKnG,EAAA,KAAaoG,kBACdxG,EAAWyG,EAC2B,GACtC,MAEJ,KAAKrG,EAAA,KAAasG,cACd1G,EAAW2G,EACwB,GACnC,MAEJ,KAAKvG,EAAA,KAAaC,oBACdL,EAAW4G,EAC8B,GACzC,MAEJ,QACI,MAAM,IAAIC,MAAM,6BAA+B9C,EAAOgC,MAG9D,OAAOhD,EAA6B/C,GAAU,EAAO8B,GAOzD,SAAS8E,EAA+B7C,EAAQjC,GAC5C,IAAIhD,EAAaiF,EAAO,cAAc+C,KAKtC,SAAU9G,GACN,OAAOyC,EAAazC,EAAU8B,MAElC,OAAO,IAAI,EAAmBhD,GAMlC,SAASmH,EAAkBlC,GACvB,OAAO,IAAIgD,EAAA,KAAMhD,EAAO,gBAM5B,SAASoC,EAAuBpC,GAC5B,OAAO,IAAIiD,EAAA,KAAWjD,EAAO,gBAMjC,SAAS0C,EAA4B1C,GACjC,OAAO,IAAIkD,EAAA,KAAgBlD,EAAO,gBAMtC,SAASwC,EAAuBxC,GAC5B,OAAO,IAAImD,EAAA,KAAWnD,EAAO,gBAMjC,SAAS4C,EAAyB5C,GAC9B,OAAO,IAAIoD,EAAA,KAAapD,EAAO,gBAMnC,SAASsC,EAAoBtC,GACzB,OAAO,IAAIqD,EAAA,KAAQrD,EAAO,gBAO9B,SAASjB,EAAc9C,EAAU8B,GAC7B9B,EAAW+C,EAA6B/C,GAAU,EAAM8B,GACxD,IAEIuF,EAFAtB,EAAO/F,EAAST,UAGpB,OAAQwG,GACJ,KAAK3F,EAAA,KAAa4F,MACdqB,EAAUC,EACW,EAAYxF,GACjC,MAEJ,KAAK1B,EAAA,KAAa8F,YACdmB,EAAUE,EACgB,EAAYzF,GACtC,MAEJ,KAAK1B,EAAA,KAAagG,QACdiB,EAAUG,EACa,EAAY1F,GACnC,MAEJ,KAAK1B,EAAA,KAAakG,YACde,EAAUI,EACgB,EAAY3F,GACtC,MAEJ,KAAK1B,EAAA,KAAaoG,kBACda,EAAUK,EACqB,EAAY5F,GAC3C,MAEJ,KAAK1B,EAAA,KAAasG,cACdW,EAAUM,EACkB,EAAY7F,GACxC,MAEJ,KAAK1B,EAAA,KAAaC,oBACdgH,EAAUO,EACwB,EAAY9F,GAC9C,MAEJ,KAAK1B,EAAA,KAAayH,OACdR,EAAU,CACNtB,KAAM,qBACNjH,WAAY,IAEhB,MAEJ,QACI,MAAM,IAAI+H,MAAM,8BAAgCd,GAGxD,OAAOsB,EAOX,SAASO,EAAgC5H,EAAU8B,GAC/C,IAAIhD,EAAakB,EAASZ,qBAAqB0H,KAAI,SAAU9G,GACzD,IAAI+B,EAAU,eAAO,GAAID,GAEzB,cADOC,EAAQM,kBACRS,EAAc9C,EAAU+B,MAEnC,MAAO,CACHgE,KAAM,qBACNjH,WAAYA,GAQpB,SAASyI,EAAwBvH,EAAU8B,GACvC,MAAO,CACHiE,KAAM,aACNxC,YAAavD,EAAS8H,kBAQ9B,SAASJ,EAA6B1H,EAAU8B,GAC5C,MAAO,CACHiE,KAAM,kBACNxC,YAAavD,EAAS8H,kBAQ9B,SAASL,EAAwBzH,EAAU8B,GACvC,MAAO,CACHiE,KAAM,aACNxC,YAAavD,EAAS8H,kBAQ9B,SAASH,EAA0B3H,EAAU8B,GACzC,IAAIiG,EAIJ,OAHIjG,IACAiG,EAAQjG,EAAYkG,aAEjB,CACHjC,KAAM,eACNxC,YAAavD,EAAS8H,eAAeC,IAQ7C,SAAST,EAAmBtH,EAAU8B,GAClC,MAAO,CACHiE,KAAM,QACNxC,YAAavD,EAAS8H,kBAQ9B,SAASN,EAAqBxH,EAAU8B,GACpC,IAAIiG,EAIJ,OAHIjG,IACAiG,EAAQjG,EAAYkG,aAEjB,CACHjC,KAAM,UACNxC,YAAavD,EAAS8H,eAAeC,IAG9B","file":"js/chunk-2d208113.b1edc57d.js","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/geom/GeometryCollection\n */\nimport EventType from '../events/EventType.js';\nimport Geometry from './Geometry.js';\nimport GeometryType from './GeometryType.js';\nimport { closestSquaredDistanceXY, createOrUpdateEmpty, extend, getCenter, } from '../extent.js';\nimport { listen, unlistenByKey } from '../events.js';\n/**\n * @classdesc\n * An array of {@link module:ol/geom/Geometry} objects.\n *\n * @api\n */\nvar GeometryCollection = /** @class */ (function (_super) {\n    __extends(GeometryCollection, _super);\n    /**\n     * @param {Array<Geometry>} [opt_geometries] Geometries.\n     */\n    function GeometryCollection(opt_geometries) {\n        var _this = _super.call(this) || this;\n        /**\n         * @private\n         * @type {Array<Geometry>}\n         */\n        _this.geometries_ = opt_geometries ? opt_geometries : null;\n        /**\n         * @type {Array<import(\"../events.js\").EventsKey>}\n         */\n        _this.changeEventsKeys_ = [];\n        _this.listenGeometriesChange_();\n        return _this;\n    }\n    /**\n     * @private\n     */\n    GeometryCollection.prototype.unlistenGeometriesChange_ = function () {\n        this.changeEventsKeys_.forEach(unlistenByKey);\n        this.changeEventsKeys_.length = 0;\n    };\n    /**\n     * @private\n     */\n    GeometryCollection.prototype.listenGeometriesChange_ = function () {\n        if (!this.geometries_) {\n            return;\n        }\n        for (var i = 0, ii = this.geometries_.length; i < ii; ++i) {\n            this.changeEventsKeys_.push(listen(this.geometries_[i], EventType.CHANGE, this.changed, this));\n        }\n    };\n    /**\n     * Make a complete copy of the geometry.\n     * @return {!GeometryCollection} Clone.\n     * @api\n     */\n    GeometryCollection.prototype.clone = function () {\n        var geometryCollection = new GeometryCollection(null);\n        geometryCollection.setGeometries(this.geometries_);\n        geometryCollection.applyProperties(this);\n        return geometryCollection;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n     * @param {number} minSquaredDistance Minimum squared distance.\n     * @return {number} Minimum squared distance.\n     */\n    GeometryCollection.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {\n        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n            return minSquaredDistance;\n        }\n        var geometries = this.geometries_;\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n            minSquaredDistance = geometries[i].closestPointXY(x, y, closestPoint, minSquaredDistance);\n        }\n        return minSquaredDistance;\n    };\n    /**\n     * @param {number} x X.\n     * @param {number} y Y.\n     * @return {boolean} Contains (x, y).\n     */\n    GeometryCollection.prototype.containsXY = function (x, y) {\n        var geometries = this.geometries_;\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n            if (geometries[i].containsXY(x, y)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @protected\n     * @return {import(\"../extent.js\").Extent} extent Extent.\n     */\n    GeometryCollection.prototype.computeExtent = function (extent) {\n        createOrUpdateEmpty(extent);\n        var geometries = this.geometries_;\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n            extend(extent, geometries[i].getExtent());\n        }\n        return extent;\n    };\n    /**\n     * Return the geometries that make up this geometry collection.\n     * @return {Array<Geometry>} Geometries.\n     * @api\n     */\n    GeometryCollection.prototype.getGeometries = function () {\n        return cloneGeometries(this.geometries_);\n    };\n    /**\n     * @return {Array<Geometry>} Geometries.\n     */\n    GeometryCollection.prototype.getGeometriesArray = function () {\n        return this.geometries_;\n    };\n    /**\n     * @return {Array<Geometry>} Geometries.\n     */\n    GeometryCollection.prototype.getGeometriesArrayRecursive = function () {\n        /** @type {Array<Geometry>} */\n        var geometriesArray = [];\n        var geometries = this.geometries_;\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n            if (geometries[i].getType() === this.getType()) {\n                geometriesArray = geometriesArray.concat(\n                /** @type {GeometryCollection} */ (geometries[i]).getGeometriesArrayRecursive());\n            }\n            else {\n                geometriesArray.push(geometries[i]);\n            }\n        }\n        return geometriesArray;\n    };\n    /**\n     * Create a simplified version of this geometry using the Douglas Peucker algorithm.\n     * @param {number} squaredTolerance Squared tolerance.\n     * @return {GeometryCollection} Simplified GeometryCollection.\n     */\n    GeometryCollection.prototype.getSimplifiedGeometry = function (squaredTolerance) {\n        if (this.simplifiedGeometryRevision !== this.getRevision()) {\n            this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n            this.simplifiedGeometryRevision = this.getRevision();\n        }\n        if (squaredTolerance < 0 ||\n            (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&\n                squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance)) {\n            return this;\n        }\n        var simplifiedGeometries = [];\n        var geometries = this.geometries_;\n        var simplified = false;\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n            var geometry = geometries[i];\n            var simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);\n            simplifiedGeometries.push(simplifiedGeometry);\n            if (simplifiedGeometry !== geometry) {\n                simplified = true;\n            }\n        }\n        if (simplified) {\n            var simplifiedGeometryCollection = new GeometryCollection(null);\n            simplifiedGeometryCollection.setGeometriesArray(simplifiedGeometries);\n            return simplifiedGeometryCollection;\n        }\n        else {\n            this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\n            return this;\n        }\n    };\n    /**\n     * Get the type of this geometry.\n     * @return {import(\"./GeometryType.js\").default} Geometry type.\n     * @api\n     */\n    GeometryCollection.prototype.getType = function () {\n        return GeometryType.GEOMETRY_COLLECTION;\n    };\n    /**\n     * Test if the geometry and the passed extent intersect.\n     * @param {import(\"../extent.js\").Extent} extent Extent.\n     * @return {boolean} `true` if the geometry and the extent intersect.\n     * @api\n     */\n    GeometryCollection.prototype.intersectsExtent = function (extent) {\n        var geometries = this.geometries_;\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n            if (geometries[i].intersectsExtent(extent)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * @return {boolean} Is empty.\n     */\n    GeometryCollection.prototype.isEmpty = function () {\n        return this.geometries_.length === 0;\n    };\n    /**\n     * Rotate the geometry around a given coordinate. This modifies the geometry\n     * coordinates in place.\n     * @param {number} angle Rotation angle in radians.\n     * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n     * @api\n     */\n    GeometryCollection.prototype.rotate = function (angle, anchor) {\n        var geometries = this.geometries_;\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n            geometries[i].rotate(angle, anchor);\n        }\n        this.changed();\n    };\n    /**\n     * Scale the geometry (with an optional origin).  This modifies the geometry\n     * coordinates in place.\n     * @abstract\n     * @param {number} sx The scaling factor in the x-direction.\n     * @param {number} [opt_sy] The scaling factor in the y-direction (defaults to sx).\n     * @param {import(\"../coordinate.js\").Coordinate} [opt_anchor] The scale origin (defaults to the center\n     *     of the geometry extent).\n     * @api\n     */\n    GeometryCollection.prototype.scale = function (sx, opt_sy, opt_anchor) {\n        var anchor = opt_anchor;\n        if (!anchor) {\n            anchor = getCenter(this.getExtent());\n        }\n        var geometries = this.geometries_;\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n            geometries[i].scale(sx, opt_sy, anchor);\n        }\n        this.changed();\n    };\n    /**\n     * Set the geometries that make up this geometry collection.\n     * @param {Array<Geometry>} geometries Geometries.\n     * @api\n     */\n    GeometryCollection.prototype.setGeometries = function (geometries) {\n        this.setGeometriesArray(cloneGeometries(geometries));\n    };\n    /**\n     * @param {Array<Geometry>} geometries Geometries.\n     */\n    GeometryCollection.prototype.setGeometriesArray = function (geometries) {\n        this.unlistenGeometriesChange_();\n        this.geometries_ = geometries;\n        this.listenGeometriesChange_();\n        this.changed();\n    };\n    /**\n     * Apply a transform function to the coordinates of the geometry.\n     * The geometry is modified in place.\n     * If you do not want the geometry modified in place, first `clone()` it and\n     * then use this function on the clone.\n     * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n     * Called with a flat array of geometry coordinates.\n     * @api\n     */\n    GeometryCollection.prototype.applyTransform = function (transformFn) {\n        var geometries = this.geometries_;\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n            geometries[i].applyTransform(transformFn);\n        }\n        this.changed();\n    };\n    /**\n     * Translate the geometry.  This modifies the geometry coordinates in place.  If\n     * instead you want a new geometry, first `clone()` this geometry.\n     * @param {number} deltaX Delta X.\n     * @param {number} deltaY Delta Y.\n     * @api\n     */\n    GeometryCollection.prototype.translate = function (deltaX, deltaY) {\n        var geometries = this.geometries_;\n        for (var i = 0, ii = geometries.length; i < ii; ++i) {\n            geometries[i].translate(deltaX, deltaY);\n        }\n        this.changed();\n    };\n    /**\n     * Clean up.\n     */\n    GeometryCollection.prototype.disposeInternal = function () {\n        this.unlistenGeometriesChange_();\n        _super.prototype.disposeInternal.call(this);\n    };\n    return GeometryCollection;\n}(Geometry));\n/**\n * @param {Array<Geometry>} geometries Geometries.\n * @return {Array<Geometry>} Cloned geometries.\n */\nfunction cloneGeometries(geometries) {\n    var clonedGeometries = [];\n    for (var i = 0, ii = geometries.length; i < ii; ++i) {\n        clonedGeometries.push(geometries[i].clone());\n    }\n    return clonedGeometries;\n}\nexport default GeometryCollection;\n//# sourceMappingURL=GeometryCollection.js.map","/**\n * @module ol/format/Feature\n */\nimport Units from '../proj/Units.js';\nimport { abstract } from '../util.js';\nimport { assign } from '../obj.js';\nimport { equivalent as equivalentProjection, get as getProjection, transformExtent, } from '../proj.js';\n/**\n * @typedef {Object} ReadOptions\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection] Projection of the data we are reading.\n * If not provided, the projection will be derived from the data (where possible) or\n * the `dataProjection` of the format is assigned (where set). If the projection\n * can not be derived from the data and if no `dataProjection` is set for a format,\n * the features will not be reprojected.\n * @property {import(\"../extent.js\").Extent} [extent] Tile extent in map units of the tile being read.\n * This is only required when reading data with tile pixels as geometry units. When configured,\n * a `dataProjection` with `TILE_PIXELS` as `units` and the tile's pixel extent as `extent` needs to be\n * provided.\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection of the feature geometries\n * created by the format reader. If not provided, features will be returned in the\n * `dataProjection`.\n */\n/**\n * @typedef {Object} WriteOptions\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection] Projection of the data we are writing.\n * If not provided, the `dataProjection` of the format is assigned (where set).\n * If no `dataProjection` is set for a format, the features will be returned\n * in the `featureProjection`.\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection of the feature geometries\n * that will be serialized by the format writer. If not provided, geometries are assumed\n * to be in the `dataProjection` if that is set; in other words, they are not transformed.\n * @property {boolean} [rightHanded] When writing geometries, follow the right-hand\n * rule for linear ring orientation.  This means that polygons will have counter-clockwise\n * exterior rings and clockwise interior rings.  By default, coordinates are serialized\n * as they are provided at construction.  If `true`, the right-hand rule will\n * be applied.  If `false`, the left-hand rule will be applied (clockwise for\n * exterior and counter-clockwise for interior rings).  Note that not all\n * formats support this.  The GeoJSON format does use this property when writing\n * geometries.\n * @property {number} [decimals] Maximum number of decimal places for coordinates.\n * Coordinates are stored internally as floats, but floating-point arithmetic can create\n * coordinates with a large number of decimal places, not generally wanted on output.\n * Set a number here to round coordinates. Can also be used to ensure that\n * coordinates read in can be written back out with the same number of decimals.\n * Default is no rounding.\n */\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for feature formats.\n * {@link module:ol/format/Feature~FeatureFormat} subclasses provide the ability to decode and encode\n * {@link module:ol/Feature~Feature} objects from a variety of commonly used geospatial\n * file formats.  See the documentation for each format for more details.\n *\n * @abstract\n * @api\n */\nvar FeatureFormat = /** @class */ (function () {\n    function FeatureFormat() {\n        /**\n         * @protected\n         * @type {import(\"../proj/Projection.js\").default|undefined}\n         */\n        this.dataProjection = undefined;\n        /**\n         * @protected\n         * @type {import(\"../proj/Projection.js\").default|undefined}\n         */\n        this.defaultFeatureProjection = undefined;\n        /**\n         * A list media types supported by the format in descending order of preference.\n         * @type {Array<string>}\n         */\n        this.supportedMediaTypes = null;\n    }\n    /**\n     * Adds the data projection to the read options.\n     * @param {Document|Element|Object|string} source Source.\n     * @param {ReadOptions} [opt_options] Options.\n     * @return {ReadOptions|undefined} Options.\n     * @protected\n     */\n    FeatureFormat.prototype.getReadOptions = function (source, opt_options) {\n        var options;\n        if (opt_options) {\n            var dataProjection = opt_options.dataProjection\n                ? getProjection(opt_options.dataProjection)\n                : this.readProjection(source);\n            if (opt_options.extent &&\n                dataProjection &&\n                dataProjection.getUnits() === Units.TILE_PIXELS) {\n                dataProjection = getProjection(dataProjection);\n                dataProjection.setWorldExtent(opt_options.extent);\n            }\n            options = {\n                dataProjection: dataProjection,\n                featureProjection: opt_options.featureProjection,\n            };\n        }\n        return this.adaptOptions(options);\n    };\n    /**\n     * Sets the `dataProjection` on the options, if no `dataProjection`\n     * is set.\n     * @param {WriteOptions|ReadOptions|undefined} options\n     *     Options.\n     * @protected\n     * @return {WriteOptions|ReadOptions|undefined}\n     *     Updated options.\n     */\n    FeatureFormat.prototype.adaptOptions = function (options) {\n        return assign({\n            dataProjection: this.dataProjection,\n            featureProjection: this.defaultFeatureProjection,\n        }, options);\n    };\n    /**\n     * @abstract\n     * @return {import(\"./FormatType.js\").default} Format.\n     */\n    FeatureFormat.prototype.getType = function () {\n        return abstract();\n    };\n    /**\n     * Read a single feature from a source.\n     *\n     * @abstract\n     * @param {Document|Element|Object|string} source Source.\n     * @param {ReadOptions} [opt_options] Read options.\n     * @return {import(\"../Feature.js\").FeatureLike} Feature.\n     */\n    FeatureFormat.prototype.readFeature = function (source, opt_options) {\n        return abstract();\n    };\n    /**\n     * Read all features from a source.\n     *\n     * @abstract\n     * @param {Document|Element|ArrayBuffer|Object|string} source Source.\n     * @param {ReadOptions} [opt_options] Read options.\n     * @return {Array<import(\"../Feature.js\").FeatureLike>} Features.\n     */\n    FeatureFormat.prototype.readFeatures = function (source, opt_options) {\n        return abstract();\n    };\n    /**\n     * Read a single geometry from a source.\n     *\n     * @abstract\n     * @param {Document|Element|Object|string} source Source.\n     * @param {ReadOptions} [opt_options] Read options.\n     * @return {import(\"../geom/Geometry.js\").default} Geometry.\n     */\n    FeatureFormat.prototype.readGeometry = function (source, opt_options) {\n        return abstract();\n    };\n    /**\n     * Read the projection from a source.\n     *\n     * @abstract\n     * @param {Document|Element|Object|string} source Source.\n     * @return {import(\"../proj/Projection.js\").default|undefined} Projection.\n     */\n    FeatureFormat.prototype.readProjection = function (source) {\n        return abstract();\n    };\n    /**\n     * Encode a feature in this format.\n     *\n     * @abstract\n     * @param {import(\"../Feature.js\").default} feature Feature.\n     * @param {WriteOptions} [opt_options] Write options.\n     * @return {string|ArrayBuffer} Result.\n     */\n    FeatureFormat.prototype.writeFeature = function (feature, opt_options) {\n        return abstract();\n    };\n    /**\n     * Encode an array of features in this format.\n     *\n     * @abstract\n     * @param {Array<import(\"../Feature.js\").default>} features Features.\n     * @param {WriteOptions} [opt_options] Write options.\n     * @return {string|ArrayBuffer} Result.\n     */\n    FeatureFormat.prototype.writeFeatures = function (features, opt_options) {\n        return abstract();\n    };\n    /**\n     * Write a single geometry in this format.\n     *\n     * @abstract\n     * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n     * @param {WriteOptions} [opt_options] Write options.\n     * @return {string|ArrayBuffer} Result.\n     */\n    FeatureFormat.prototype.writeGeometry = function (geometry, opt_options) {\n        return abstract();\n    };\n    return FeatureFormat;\n}());\nexport default FeatureFormat;\n/**\n * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {boolean} write Set to true for writing, false for reading.\n * @param {WriteOptions|ReadOptions} [opt_options] Options.\n * @return {import(\"../geom/Geometry.js\").default} Transformed geometry.\n */\nexport function transformGeometryWithOptions(geometry, write, opt_options) {\n    var featureProjection = opt_options\n        ? getProjection(opt_options.featureProjection)\n        : null;\n    var dataProjection = opt_options\n        ? getProjection(opt_options.dataProjection)\n        : null;\n    var transformed;\n    if (featureProjection &&\n        dataProjection &&\n        !equivalentProjection(featureProjection, dataProjection)) {\n        transformed = (write ? geometry.clone() : geometry).transform(write ? featureProjection : dataProjection, write ? dataProjection : featureProjection);\n    }\n    else {\n        transformed = geometry;\n    }\n    if (write &&\n        opt_options &&\n        /** @type {WriteOptions} */ (opt_options).decimals !== undefined) {\n        var power_1 = Math.pow(10, \n        /** @type {WriteOptions} */ (opt_options).decimals);\n        // if decimals option on write, round each coordinate appropriately\n        /**\n         * @param {Array<number>} coordinates Coordinates.\n         * @return {Array<number>} Transformed coordinates.\n         */\n        var transform = function (coordinates) {\n            for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n                coordinates[i] = Math.round(coordinates[i] * power_1) / power_1;\n            }\n            return coordinates;\n        };\n        if (transformed === geometry) {\n            transformed = geometry.clone();\n        }\n        transformed.applyTransform(transform);\n    }\n    return transformed;\n}\n/**\n * @param {import(\"../extent.js\").Extent} extent Extent.\n * @param {ReadOptions} [opt_options] Read options.\n * @return {import(\"../extent.js\").Extent} Transformed extent.\n */\nexport function transformExtentWithOptions(extent, opt_options) {\n    var featureProjection = opt_options\n        ? getProjection(opt_options.featureProjection)\n        : null;\n    var dataProjection = opt_options\n        ? getProjection(opt_options.dataProjection)\n        : null;\n    if (featureProjection &&\n        dataProjection &&\n        !equivalentProjection(featureProjection, dataProjection)) {\n        return transformExtent(extent, dataProjection, featureProjection);\n    }\n    else {\n        return extent;\n    }\n}\n//# sourceMappingURL=Feature.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/format/JSONFeature\n */\nimport FeatureFormat from './Feature.js';\nimport FormatType from './FormatType.js';\nimport { abstract } from '../util.js';\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for JSON feature formats.\n *\n * @abstract\n */\nvar JSONFeature = /** @class */ (function (_super) {\n    __extends(JSONFeature, _super);\n    function JSONFeature() {\n        return _super.call(this) || this;\n    }\n    /**\n     * @return {import(\"./FormatType.js\").default} Format.\n     */\n    JSONFeature.prototype.getType = function () {\n        return FormatType.JSON;\n    };\n    /**\n     * Read a feature.  Only works for a single feature. Use `readFeatures` to\n     * read a feature collection.\n     *\n     * @param {ArrayBuffer|Document|Element|Object|string} source Source.\n     * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n     * @return {import(\"../Feature.js\").default} Feature.\n     * @api\n     */\n    JSONFeature.prototype.readFeature = function (source, opt_options) {\n        return this.readFeatureFromObject(getObject(source), this.getReadOptions(source, opt_options));\n    };\n    /**\n     * Read all features.  Works with both a single feature and a feature\n     * collection.\n     *\n     * @param {ArrayBuffer|Document|Element|Object|string} source Source.\n     * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n     * @return {Array<import(\"../Feature.js\").default>} Features.\n     * @api\n     */\n    JSONFeature.prototype.readFeatures = function (source, opt_options) {\n        return this.readFeaturesFromObject(getObject(source), this.getReadOptions(source, opt_options));\n    };\n    /**\n     * @abstract\n     * @param {Object} object Object.\n     * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n     * @protected\n     * @return {import(\"../Feature.js\").default} Feature.\n     */\n    JSONFeature.prototype.readFeatureFromObject = function (object, opt_options) {\n        return abstract();\n    };\n    /**\n     * @abstract\n     * @param {Object} object Object.\n     * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n     * @protected\n     * @return {Array<import(\"../Feature.js\").default>} Features.\n     */\n    JSONFeature.prototype.readFeaturesFromObject = function (object, opt_options) {\n        return abstract();\n    };\n    /**\n     * Read a geometry.\n     *\n     * @param {ArrayBuffer|Document|Element|Object|string} source Source.\n     * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n     * @return {import(\"../geom/Geometry.js\").default} Geometry.\n     * @api\n     */\n    JSONFeature.prototype.readGeometry = function (source, opt_options) {\n        return this.readGeometryFromObject(getObject(source), this.getReadOptions(source, opt_options));\n    };\n    /**\n     * @abstract\n     * @param {Object} object Object.\n     * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n     * @protected\n     * @return {import(\"../geom/Geometry.js\").default} Geometry.\n     */\n    JSONFeature.prototype.readGeometryFromObject = function (object, opt_options) {\n        return abstract();\n    };\n    /**\n     * Read the projection.\n     *\n     * @param {ArrayBuffer|Document|Element|Object|string} source Source.\n     * @return {import(\"../proj/Projection.js\").default} Projection.\n     * @api\n     */\n    JSONFeature.prototype.readProjection = function (source) {\n        return this.readProjectionFromObject(getObject(source));\n    };\n    /**\n     * @abstract\n     * @param {Object} object Object.\n     * @protected\n     * @return {import(\"../proj/Projection.js\").default} Projection.\n     */\n    JSONFeature.prototype.readProjectionFromObject = function (object) {\n        return abstract();\n    };\n    /**\n     * Encode a feature as string.\n     *\n     * @param {import(\"../Feature.js\").default} feature Feature.\n     * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n     * @return {string} Encoded feature.\n     * @api\n     */\n    JSONFeature.prototype.writeFeature = function (feature, opt_options) {\n        return JSON.stringify(this.writeFeatureObject(feature, opt_options));\n    };\n    /**\n     * @abstract\n     * @param {import(\"../Feature.js\").default} feature Feature.\n     * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n     * @return {Object} Object.\n     */\n    JSONFeature.prototype.writeFeatureObject = function (feature, opt_options) {\n        return abstract();\n    };\n    /**\n     * Encode an array of features as string.\n     *\n     * @param {Array<import(\"../Feature.js\").default>} features Features.\n     * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n     * @return {string} Encoded features.\n     * @api\n     */\n    JSONFeature.prototype.writeFeatures = function (features, opt_options) {\n        return JSON.stringify(this.writeFeaturesObject(features, opt_options));\n    };\n    /**\n     * @abstract\n     * @param {Array<import(\"../Feature.js\").default>} features Features.\n     * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n     * @return {Object} Object.\n     */\n    JSONFeature.prototype.writeFeaturesObject = function (features, opt_options) {\n        return abstract();\n    };\n    /**\n     * Encode a geometry as string.\n     *\n     * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n     * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n     * @return {string} Encoded geometry.\n     * @api\n     */\n    JSONFeature.prototype.writeGeometry = function (geometry, opt_options) {\n        return JSON.stringify(this.writeGeometryObject(geometry, opt_options));\n    };\n    /**\n     * @abstract\n     * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n     * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n     * @return {Object} Object.\n     */\n    JSONFeature.prototype.writeGeometryObject = function (geometry, opt_options) {\n        return abstract();\n    };\n    return JSONFeature;\n}(FeatureFormat));\n/**\n * @param {Document|Element|Object|string} source Source.\n * @return {Object} Object.\n */\nfunction getObject(source) {\n    if (typeof source === 'string') {\n        var object = JSON.parse(source);\n        return object ? /** @type {Object} */ (object) : null;\n    }\n    else if (source !== null) {\n        return source;\n    }\n    else {\n        return null;\n    }\n}\nexport default JSONFeature;\n//# sourceMappingURL=JSONFeature.js.map","/**\n * @module ol/format/GeoJSON\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport Feature from '../Feature.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport GeometryType from '../geom/GeometryType.js';\nimport JSONFeature from './JSONFeature.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport { assert } from '../asserts.js';\nimport { assign, isEmpty } from '../obj.js';\nimport { get as getProjection } from '../proj.js';\nimport { transformGeometryWithOptions } from './Feature.js';\n/**\n * @typedef {import(\"geojson\").GeoJSON} GeoJSONObject\n * @typedef {import(\"geojson\").Feature} GeoJSONFeature\n * @typedef {import(\"geojson\").FeatureCollection} GeoJSONFeatureCollection\n * @typedef {import(\"geojson\").Geometry} GeoJSONGeometry\n * @typedef {import(\"geojson\").Point} GeoJSONPoint\n * @typedef {import(\"geojson\").LineString} GeoJSONLineString\n * @typedef {import(\"geojson\").Polygon} GeoJSONPolygon\n * @typedef {import(\"geojson\").MultiPoint} GeoJSONMultiPoint\n * @typedef {import(\"geojson\").MultiLineString} GeoJSONMultiLineString\n * @typedef {import(\"geojson\").MultiPolygon} GeoJSONMultiPolygon\n * @typedef {import(\"geojson\").GeometryCollection} GeoJSONGeometryCollection\n */\n/**\n * @typedef {Object} Options\n * @property {import(\"../proj.js\").ProjectionLike} [dataProjection='EPSG:4326'] Default data projection.\n * @property {import(\"../proj.js\").ProjectionLike} [featureProjection] Projection for features read or\n * written by the format.  Options passed to read or write methods will take precedence.\n * @property {string} [geometryName] Geometry name to use when creating features.\n * @property {boolean} [extractGeometryName=false] Certain GeoJSON providers include\n * the geometry_name field in the feature GeoJSON. If set to `true` the GeoJSON reader\n * will look for that field to set the geometry name. If both this field is set to `true`\n * and a `geometryName` is provided, the `geometryName` will take precedence.\n */\n/**\n * @classdesc\n * Feature format for reading and writing data in the GeoJSON format.\n *\n * @api\n */\nvar GeoJSON = /** @class */ (function (_super) {\n    __extends(GeoJSON, _super);\n    /**\n     * @param {Options} [opt_options] Options.\n     */\n    function GeoJSON(opt_options) {\n        var _this = this;\n        var options = opt_options ? opt_options : {};\n        _this = _super.call(this) || this;\n        /**\n         * @type {import(\"../proj/Projection.js\").default}\n         */\n        _this.dataProjection = getProjection(options.dataProjection ? options.dataProjection : 'EPSG:4326');\n        if (options.featureProjection) {\n            _this.defaultFeatureProjection = getProjection(options.featureProjection);\n        }\n        /**\n         * Name of the geometry attribute for features.\n         * @type {string|undefined}\n         * @private\n         */\n        _this.geometryName_ = options.geometryName;\n        /**\n         * Look for the geometry name in the feature GeoJSON\n         * @type {boolean|undefined}\n         * @private\n         */\n        _this.extractGeometryName_ = options.extractGeometryName;\n        _this.supportedMediaTypes = [\n            'application/geo+json',\n            'application/vnd.geo+json',\n        ];\n        return _this;\n    }\n    /**\n     * @param {Object} object Object.\n     * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n     * @protected\n     * @return {import(\"../Feature.js\").default} Feature.\n     */\n    GeoJSON.prototype.readFeatureFromObject = function (object, opt_options) {\n        /**\n         * @type {GeoJSONFeature}\n         */\n        var geoJSONFeature = null;\n        if (object['type'] === 'Feature') {\n            geoJSONFeature = /** @type {GeoJSONFeature} */ (object);\n        }\n        else {\n            geoJSONFeature = {\n                'type': 'Feature',\n                'geometry': /** @type {GeoJSONGeometry} */ (object),\n                'properties': null,\n            };\n        }\n        var geometry = readGeometry(geoJSONFeature['geometry'], opt_options);\n        var feature = new Feature();\n        if (this.geometryName_) {\n            feature.setGeometryName(this.geometryName_);\n        }\n        else if (this.extractGeometryName_ &&\n            'geometry_name' in geoJSONFeature !== undefined) {\n            feature.setGeometryName(geoJSONFeature['geometry_name']);\n        }\n        feature.setGeometry(geometry);\n        if ('id' in geoJSONFeature) {\n            feature.setId(geoJSONFeature['id']);\n        }\n        if (geoJSONFeature['properties']) {\n            feature.setProperties(geoJSONFeature['properties'], true);\n        }\n        return feature;\n    };\n    /**\n     * @param {Object} object Object.\n     * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n     * @protected\n     * @return {Array<Feature>} Features.\n     */\n    GeoJSON.prototype.readFeaturesFromObject = function (object, opt_options) {\n        var geoJSONObject = /** @type {GeoJSONObject} */ (object);\n        /** @type {Array<import(\"../Feature.js\").default>} */\n        var features = null;\n        if (geoJSONObject['type'] === 'FeatureCollection') {\n            var geoJSONFeatureCollection = /** @type {GeoJSONFeatureCollection} */ (object);\n            features = [];\n            var geoJSONFeatures = geoJSONFeatureCollection['features'];\n            for (var i = 0, ii = geoJSONFeatures.length; i < ii; ++i) {\n                features.push(this.readFeatureFromObject(geoJSONFeatures[i], opt_options));\n            }\n        }\n        else {\n            features = [this.readFeatureFromObject(object, opt_options)];\n        }\n        return features;\n    };\n    /**\n     * @param {GeoJSONGeometry} object Object.\n     * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n     * @protected\n     * @return {import(\"../geom/Geometry.js\").default} Geometry.\n     */\n    GeoJSON.prototype.readGeometryFromObject = function (object, opt_options) {\n        return readGeometry(object, opt_options);\n    };\n    /**\n     * @param {Object} object Object.\n     * @protected\n     * @return {import(\"../proj/Projection.js\").default} Projection.\n     */\n    GeoJSON.prototype.readProjectionFromObject = function (object) {\n        var crs = object['crs'];\n        var projection;\n        if (crs) {\n            if (crs['type'] == 'name') {\n                projection = getProjection(crs['properties']['name']);\n            }\n            else if (crs['type'] === 'EPSG') {\n                projection = getProjection('EPSG:' + crs['properties']['code']);\n            }\n            else {\n                assert(false, 36); // Unknown SRS type\n            }\n        }\n        else {\n            projection = this.dataProjection;\n        }\n        return /** @type {import(\"../proj/Projection.js\").default} */ (projection);\n    };\n    /**\n     * Encode a feature as a GeoJSON Feature object.\n     *\n     * @param {import(\"../Feature.js\").default} feature Feature.\n     * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n     * @return {GeoJSONFeature} Object.\n     * @api\n     */\n    GeoJSON.prototype.writeFeatureObject = function (feature, opt_options) {\n        opt_options = this.adaptOptions(opt_options);\n        /** @type {GeoJSONFeature} */\n        var object = {\n            'type': 'Feature',\n            geometry: null,\n            properties: null,\n        };\n        var id = feature.getId();\n        if (id !== undefined) {\n            object.id = id;\n        }\n        if (!feature.hasProperties()) {\n            return object;\n        }\n        var properties = feature.getProperties();\n        var geometry = feature.getGeometry();\n        if (geometry) {\n            object.geometry = writeGeometry(geometry, opt_options);\n            delete properties[feature.getGeometryName()];\n        }\n        if (!isEmpty(properties)) {\n            object.properties = properties;\n        }\n        return object;\n    };\n    /**\n     * Encode an array of features as a GeoJSON object.\n     *\n     * @param {Array<import(\"../Feature.js\").default>} features Features.\n     * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n     * @return {GeoJSONFeatureCollection} GeoJSON Object.\n     * @api\n     */\n    GeoJSON.prototype.writeFeaturesObject = function (features, opt_options) {\n        opt_options = this.adaptOptions(opt_options);\n        var objects = [];\n        for (var i = 0, ii = features.length; i < ii; ++i) {\n            objects.push(this.writeFeatureObject(features[i], opt_options));\n        }\n        return {\n            type: 'FeatureCollection',\n            features: objects,\n        };\n    };\n    /**\n     * Encode a geometry as a GeoJSON object.\n     *\n     * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n     * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n     * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.\n     * @api\n     */\n    GeoJSON.prototype.writeGeometryObject = function (geometry, opt_options) {\n        return writeGeometry(geometry, this.adaptOptions(opt_options));\n    };\n    return GeoJSON;\n}(JSONFeature));\n/**\n * @param {GeoJSONGeometry|GeoJSONGeometryCollection} object Object.\n * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n * @return {import(\"../geom/Geometry.js\").default} Geometry.\n */\nfunction readGeometry(object, opt_options) {\n    if (!object) {\n        return null;\n    }\n    /**\n     * @type {import(\"../geom/Geometry.js\").default}\n     */\n    var geometry;\n    switch (object['type']) {\n        case GeometryType.POINT: {\n            geometry = readPointGeometry(/** @type {GeoJSONPoint} */ (object));\n            break;\n        }\n        case GeometryType.LINE_STRING: {\n            geometry = readLineStringGeometry(\n            /** @type {GeoJSONLineString} */ (object));\n            break;\n        }\n        case GeometryType.POLYGON: {\n            geometry = readPolygonGeometry(/** @type {GeoJSONPolygon} */ (object));\n            break;\n        }\n        case GeometryType.MULTI_POINT: {\n            geometry = readMultiPointGeometry(\n            /** @type {GeoJSONMultiPoint} */ (object));\n            break;\n        }\n        case GeometryType.MULTI_LINE_STRING: {\n            geometry = readMultiLineStringGeometry(\n            /** @type {GeoJSONMultiLineString} */ (object));\n            break;\n        }\n        case GeometryType.MULTI_POLYGON: {\n            geometry = readMultiPolygonGeometry(\n            /** @type {GeoJSONMultiPolygon} */ (object));\n            break;\n        }\n        case GeometryType.GEOMETRY_COLLECTION: {\n            geometry = readGeometryCollectionGeometry(\n            /** @type {GeoJSONGeometryCollection} */ (object));\n            break;\n        }\n        default: {\n            throw new Error('Unsupported GeoJSON type: ' + object.type);\n        }\n    }\n    return transformGeometryWithOptions(geometry, false, opt_options);\n}\n/**\n * @param {GeoJSONGeometryCollection} object Object.\n * @param {import(\"./Feature.js\").ReadOptions} [opt_options] Read options.\n * @return {GeometryCollection} Geometry collection.\n */\nfunction readGeometryCollectionGeometry(object, opt_options) {\n    var geometries = object['geometries'].map(\n    /**\n     * @param {GeoJSONGeometry} geometry Geometry.\n     * @return {import(\"../geom/Geometry.js\").default} geometry Geometry.\n     */\n    function (geometry) {\n        return readGeometry(geometry, opt_options);\n    });\n    return new GeometryCollection(geometries);\n}\n/**\n * @param {GeoJSONPoint} object Object.\n * @return {Point} Point.\n */\nfunction readPointGeometry(object) {\n    return new Point(object['coordinates']);\n}\n/**\n * @param {GeoJSONLineString} object Object.\n * @return {LineString} LineString.\n */\nfunction readLineStringGeometry(object) {\n    return new LineString(object['coordinates']);\n}\n/**\n * @param {GeoJSONMultiLineString} object Object.\n * @return {MultiLineString} MultiLineString.\n */\nfunction readMultiLineStringGeometry(object) {\n    return new MultiLineString(object['coordinates']);\n}\n/**\n * @param {GeoJSONMultiPoint} object Object.\n * @return {MultiPoint} MultiPoint.\n */\nfunction readMultiPointGeometry(object) {\n    return new MultiPoint(object['coordinates']);\n}\n/**\n * @param {GeoJSONMultiPolygon} object Object.\n * @return {MultiPolygon} MultiPolygon.\n */\nfunction readMultiPolygonGeometry(object) {\n    return new MultiPolygon(object['coordinates']);\n}\n/**\n * @param {GeoJSONPolygon} object Object.\n * @return {Polygon} Polygon.\n */\nfunction readPolygonGeometry(object) {\n    return new Polygon(object['coordinates']);\n}\n/**\n * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeGeometry(geometry, opt_options) {\n    geometry = transformGeometryWithOptions(geometry, true, opt_options);\n    var type = geometry.getType();\n    /** @type {GeoJSONGeometry} */\n    var geoJSON;\n    switch (type) {\n        case GeometryType.POINT: {\n            geoJSON = writePointGeometry(\n            /** @type {Point} */ (geometry), opt_options);\n            break;\n        }\n        case GeometryType.LINE_STRING: {\n            geoJSON = writeLineStringGeometry(\n            /** @type {LineString} */ (geometry), opt_options);\n            break;\n        }\n        case GeometryType.POLYGON: {\n            geoJSON = writePolygonGeometry(\n            /** @type {Polygon} */ (geometry), opt_options);\n            break;\n        }\n        case GeometryType.MULTI_POINT: {\n            geoJSON = writeMultiPointGeometry(\n            /** @type {MultiPoint} */ (geometry), opt_options);\n            break;\n        }\n        case GeometryType.MULTI_LINE_STRING: {\n            geoJSON = writeMultiLineStringGeometry(\n            /** @type {MultiLineString} */ (geometry), opt_options);\n            break;\n        }\n        case GeometryType.MULTI_POLYGON: {\n            geoJSON = writeMultiPolygonGeometry(\n            /** @type {MultiPolygon} */ (geometry), opt_options);\n            break;\n        }\n        case GeometryType.GEOMETRY_COLLECTION: {\n            geoJSON = writeGeometryCollectionGeometry(\n            /** @type {GeometryCollection} */ (geometry), opt_options);\n            break;\n        }\n        case GeometryType.CIRCLE: {\n            geoJSON = {\n                type: 'GeometryCollection',\n                geometries: [],\n            };\n            break;\n        }\n        default: {\n            throw new Error('Unsupported geometry type: ' + type);\n        }\n    }\n    return geoJSON;\n}\n/**\n * @param {GeometryCollection} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n * @return {GeoJSONGeometryCollection} GeoJSON geometry collection.\n */\nfunction writeGeometryCollectionGeometry(geometry, opt_options) {\n    var geometries = geometry.getGeometriesArray().map(function (geometry) {\n        var options = assign({}, opt_options);\n        delete options.featureProjection;\n        return writeGeometry(geometry, options);\n    });\n    return {\n        type: 'GeometryCollection',\n        geometries: geometries,\n    };\n}\n/**\n * @param {LineString} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeLineStringGeometry(geometry, opt_options) {\n    return {\n        type: 'LineString',\n        coordinates: geometry.getCoordinates(),\n    };\n}\n/**\n * @param {MultiLineString} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeMultiLineStringGeometry(geometry, opt_options) {\n    return {\n        type: 'MultiLineString',\n        coordinates: geometry.getCoordinates(),\n    };\n}\n/**\n * @param {MultiPoint} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeMultiPointGeometry(geometry, opt_options) {\n    return {\n        type: 'MultiPoint',\n        coordinates: geometry.getCoordinates(),\n    };\n}\n/**\n * @param {MultiPolygon} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writeMultiPolygonGeometry(geometry, opt_options) {\n    var right;\n    if (opt_options) {\n        right = opt_options.rightHanded;\n    }\n    return {\n        type: 'MultiPolygon',\n        coordinates: geometry.getCoordinates(right),\n    };\n}\n/**\n * @param {Point} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writePointGeometry(geometry, opt_options) {\n    return {\n        type: 'Point',\n        coordinates: geometry.getCoordinates(),\n    };\n}\n/**\n * @param {Polygon} geometry Geometry.\n * @param {import(\"./Feature.js\").WriteOptions} [opt_options] Write options.\n * @return {GeoJSONGeometry} GeoJSON geometry.\n */\nfunction writePolygonGeometry(geometry, opt_options) {\n    var right;\n    if (opt_options) {\n        right = opt_options.rightHanded;\n    }\n    return {\n        type: 'Polygon',\n        coordinates: geometry.getCoordinates(right),\n    };\n}\nexport default GeoJSON;\n//# sourceMappingURL=GeoJSON.js.map"],"sourceRoot":""}