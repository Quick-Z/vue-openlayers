{"version":3,"sources":["webpack:///./src/views/heatmap/heatmap.vue?d494","webpack:///./node_modules/ol/webgl.js","webpack:///./node_modules/ol/webgl/Buffer.js","webpack:///./node_modules/ol/webgl/ContextEventType.js","webpack:///./node_modules/ol/webgl/PostProcessingPass.js","webpack:///./node_modules/ol/vec/mat4.js","webpack:///./node_modules/ol/webgl/Helper.js","webpack:///./node_modules/ol/renderer/webgl/Layer.js","webpack:///./node_modules/ol/webgl/RenderTarget.js","webpack:///./node_modules/ol/worker/webgl.js","webpack:///./node_modules/ol/renderer/webgl/PointsLayer.js","webpack:///./node_modules/ol/layer/Heatmap.js","webpack:///./node_modules/ol/source/Stamen.js","webpack:///src/views/heatmap/heatmap.vue","webpack:///./src/views/heatmap/heatmap.vue?2971","webpack:///./src/views/heatmap/heatmap.vue"],"names":["supportedExtensions","render","_vm","this","_h","$createElement","_c","_self","staticClass","_v","directives","name","rawName","value","expression","attrs","domProps","on","changeRadius","$event","radius","target","changeBlur","blur","getHeatName","ref","staticRenderFns","ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER","STREAM_DRAW","STATIC_DRAW","DYNAMIC_DRAW","UNSIGNED_BYTE","UNSIGNED_SHORT","UNSIGNED_INT","FLOAT","CONTEXT_IDS","getContext","canvas","opt_attributes","ii","length","i","context","e","getSupportedExtensions","document","createElement","gl","BufferUsage","WebGLArrayBuffer","type","opt_usage","array","usage","undefined","prototype","ofSize","size","getArrayClassForType","fromArray","from","fromArrayBuffer","buffer","getType","getArray","getUsage","getSize","Float32Array","Uint32Array","LOST","RESTORED","DEFAULT_VERTEX_SHADER","DEFAULT_FRAGMENT_SHADER","WebGLPostProcessingPass","options","gl_","webGlContext","scaleRatio_","scaleRatio","renderTargetTexture_","createTexture","renderTargetTextureSize_","frameBuffer_","createFramebuffer","vertexShader","createShader","VERTEX_SHADER","shaderSource","compileShader","fragmentShader","FRAGMENT_SHADER","renderTargetProgram_","createProgram","attachShader","linkProgram","renderTargetVerticesBuffer_","createBuffer","verticesArray","bindBuffer","bufferData","renderTargetAttribLocation_","getAttribLocation","renderTargetUniformLocation_","getUniformLocation","renderTargetTextureLocation_","uniforms_","uniforms","Object","keys","forEach","push","location","bind","getGL","init","frameState","textureSize","drawingBufferWidth","drawingBufferHeight","bindFramebuffer","FRAMEBUFFER","getFrameBuffer","viewport","level","internalFormat","RGBA","border","format","data","bindTexture","TEXTURE_2D","texImage2D","texParameteri","TEXTURE_MIN_FILTER","LINEAR","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","framebufferTexture2D","COLOR_ATTACHMENT0","apply","nextPass","activeTexture","TEXTURE0","clearColor","clear","COLOR_BUFFER_BIT","enable","BLEND","blendFunc","ONE","ONE_MINUS_SRC_ALPHA","useProgram","enableVertexAttribArray","vertexAttribPointer","uniform2f","uniform1i","applyUniforms","drawArrays","TRIANGLES","textureSlot","uniform","HTMLCanvasElement","ImageData","texture","width","height","Uint8Array","Array","isArray","uniform3f","uniform4f","uniform1f","create","fromTransform","mat4","transform","__extends","extendStatics","d","b","setPrototypeOf","__proto__","p","hasOwnProperty","call","TypeError","String","__","constructor","DefaultUniform","PROJECTION_MATRIX","OFFSET_SCALE_MATRIX","OFFSET_ROTATION_MATRIX","TIME","ZOOM","RESOLUTION","AttributeType","_super","WebGLHelper","opt_options","_this","boundHandleWebGLContextLost_","handleWebGLContextLost","boundHandleWebGLContextRestored_","handleWebGLContextRestored","canvas_","style","position","left","bufferCache_","currentProgram_","getExtension","addEventListener","ContextEventType","offsetRotateMatrix_","offsetScaleMatrix_","tmpMat4_","uniformLocations_","attribLocations_","name_1","postProcessPasses_","postProcesses","map","shaderCompileErrors_","startTime_","Date","now","bufferKey","bufferCache","webGlBuffer","flushBufferData","deleteBuffer","buf","bufferCacheEntry","isContextLost","disposeInternal","removeEventListener","prepareDraw","opt_disableAlphaBlend","getCanvas","pixelRatio","ZERO","applyFrameState","prepareDrawToRenderTarget","renderTarget","getFramebuffer","getTexture","drawElements","start","end","elementType","elementSize","numItems","offsetInBytes","finalizeDraw","rotation","viewState","offsetScaleMatrix","offsetRotateMatrix","setUniformMatrixValue","setUniformFloatValue","zoom","resolution","HTMLImageElement","prevValue","imageReady","complete","program","source","shader","getProgram","fragmentShaderSource","vertexShaderSource","getShaderParameter","COMPILE_STATUS","message","getShaderInfoLog","Error","deleteShader","getProgramParameter","LINK_STATUS","getAttributeLocation","makeProjectionTransform","center","uniformMatrix4fv","enableAttributeArray_","attribName","stride","offset","enableAttributes","attributes","computeAttributesStride","attr","getByteSizeFromType","opt_data","opt_texture","Disposable","BYTES_PER_ELEMENT","Uint16Array","WebGLWorkerMessageType","GENERATE_BUFFERS","WebGLLayerRenderer","layer","helper","className","dispose","dispatchRenderEvent_","getLayer","hasListener","event_1","dispatchEvent","preRender","PRERENDER","postRender","POSTRENDER","Layer","colorEncodeId","id","opt_array","radix","divide","Math","floor","colorDecodeId","color","mult","round","tmpArray4","WebGLRenderTarget","opt_size","helper_","texture_","framebuffer_","size_","data_","dataCacheDirty_","updateSize_","setSize","clearCachedData","readAll","readPixels","readPixel","x","y","index","blob","Blob","url","URL","createObjectURL","Worker","WebGLPointsLayerRenderer","projectionMatrixTransform","sourceRevision_","verticesBuffer_","hitVerticesBuffer_","indicesBuffer_","program_","hitDetectionEnabled_","hitFragmentShader","hitVertexShader","hitProgram_","customAttributes","attribute","concat","hitDetectionAttributes","previousExtent_","currentTransform_","renderTransform_","invertRenderTransform_","renderInstructions_","hitRenderInstructions_","hitRenderTarget_","worker_","event","received","projectionTransform","hitDetection","vertexBuffer","indexBuffer","renderInstructions","changed","featureCache_","featureCount_","getSource","sourceListenKeys_","VectorEventType","ADDFEATURE","handleSourceFeatureAdded_","CHANGEFEATURE","handleSourceFeatureChanged_","REMOVEFEATURE","handleSourceFeatureDelete_","CLEAR","handleSourceFeatureClear_","forEachFeature","feature","properties","getProperties","geometry","getGeometry","renderFrame","renderCount","layerState","layerStatesArray","layerIndex","opacity","parseFloat","renderHitDetection","prepareFrame","vectorSource","viewNotMoving","viewHints","ViewHint","ANIMATING","INTERACTING","extentChanged","extent","sourceChanged","getRevision","projection","renderBuffer","BaseVector","getRenderBuffer","loadFeatures","rebuildBuffers_","slice","featureCache","totalInstructionsCount","totalHitInstructionsCount","hitColor","tmpCoords","tmpColor","renderIndex","hitIndex","featureUid","GeometryType","POINT","getFlatCoordinates","Number","j","callback","customAttributesCount","postMessage","hitMessage","forEachFeatureAtCoordinate","coordinate","hitTolerance","matches","pixel","coordinateToPixelTransform","uid","toString","getFeatureByUid","terminate","layer_","key","Property","BLUR","GRADIENT","RADIUS","DEFAULT_GRADIENT","Heatmap","baseOptions","gradient","weight","gradient_","addChangeListener","handleGradientChanged_","setGradient","setBlur","setRadius","weightFunction_","get","setRenderOrder","getBlur","getGradient","getRadius","createGradient","set","colors","createRenderer","getClassName","u_size","u_blurSlope","max","u_gradientTexture","renderDeclutter","Vector","createLinearGradient","step","addColorStop","fillStyle","fillRect","ATTRIBUTIONS","OSM","LayerConfig","extension","opaque","ProviderConfig","minZoom","maxZoom","Stamen","indexOf","provider","providerConfig","layerConfig","attributions","cacheSize","crossOrigin","imageSmoothing","reprojectionErrorThreshold","tileLoadFunction","transition","wrapX","zDirection","XYZ","vector","features","GeoJSON","dataProjection","featureProjection","methods","initMap","Map","$refs","layers","raster","view","View","parseInt","getLength","console","log","item","mounted","component"],"mappings":"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","file":"js/chunk-2e693b48.0d000a22.js","sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"vm\"},[_c('h2',{staticClass:\"h-title\"},[_vm._v(\"热力图 Heatmap\")]),_c('label',[_vm._v(\"半径大小\")]),_c('input',{directives:[{name:\"model\",rawName:\"v-model\",value:(_vm.radius),expression:\"radius\"}],attrs:{\"id\":\"radius\",\"type\":\"range\",\"min\":\"1\",\"max\":\"50\",\"step\":\"1\"},domProps:{\"value\":(_vm.radius)},on:{\"change\":_vm.changeRadius,\"__r\":function($event){_vm.radius=$event.target.value}}}),_c('label',[_vm._v(\"模糊半径\")]),_c('input',{directives:[{name:\"model\",rawName:\"v-model\",value:(_vm.blur),expression:\"blur\"}],attrs:{\"id\":\"blur\",\"type\":\"range\",\"min\":\"1\",\"max\":\"50\",\"step\":\"1\"},domProps:{\"value\":(_vm.blur)},on:{\"change\":_vm.changeBlur,\"__r\":function($event){_vm.blur=$event.target.value}}}),_c('button',{on:{\"click\":_vm.getHeatName}},[_vm._v(\"输出涂层名\")]),_c('div',{ref:\"map\",staticClass:\"map-x\",attrs:{\"id\":\"map\"}})])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","/**\n * @module ol/webgl\n */\n/**\n * Constants taken from goog.webgl\n */\n/**\n * Used by {@link module:ol/webgl/Helper~WebGLHelper} for buffers containing vertices data, such as\n * position, color, texture coordinate, etc. These vertices are then referenced by an index buffer\n * to be drawn on screen (see {@link module:ol/webgl.ELEMENT_ARRAY_BUFFER}).\n * @const\n * @type {number}\n * @api\n */\nexport var ARRAY_BUFFER = 0x8892;\n/**\n * Used by {@link module:ol/webgl/Helper~WebGLHelper} for buffers containing indices data.\n * Index buffers are essentially lists of references to vertices defined in a vertex buffer\n * (see {@link module:ol/webgl.ARRAY_BUFFER}), and define the primitives (triangles) to be drawn.\n * @const\n * @type {number}\n * @api\n */\nexport var ELEMENT_ARRAY_BUFFER = 0x8893;\n/**\n * Used by {link module:ol/webgl/Buffer~WebGLArrayBuffer}.\n * @const\n * @type {number}\n * @api\n */\nexport var STREAM_DRAW = 0x88e0;\n/**\n * Used by {link module:ol/webgl/Buffer~WebGLArrayBuffer}.\n * @const\n * @type {number}\n * @api\n */\nexport var STATIC_DRAW = 0x88e4;\n/**\n * Used by {link module:ol/webgl/Buffer~WebGLArrayBuffer}.\n * @const\n * @type {number}\n * @api\n */\nexport var DYNAMIC_DRAW = 0x88e8;\n/**\n * @const\n * @type {number}\n */\nexport var UNSIGNED_BYTE = 0x1401;\n/**\n * @const\n * @type {number}\n */\nexport var UNSIGNED_SHORT = 0x1403;\n/**\n * @const\n * @type {number}\n */\nexport var UNSIGNED_INT = 0x1405;\n/**\n * @const\n * @type {number}\n */\nexport var FLOAT = 0x1406;\n/** end of goog.webgl constants\n */\n/**\n * @const\n * @type {Array<string>}\n */\nvar CONTEXT_IDS = ['experimental-webgl', 'webgl', 'webkit-3d', 'moz-webgl'];\n/**\n * @param {HTMLCanvasElement} canvas Canvas.\n * @param {Object} [opt_attributes] Attributes.\n * @return {WebGLRenderingContext} WebGL rendering context.\n */\nexport function getContext(canvas, opt_attributes) {\n    var ii = CONTEXT_IDS.length;\n    for (var i = 0; i < ii; ++i) {\n        try {\n            var context = canvas.getContext(CONTEXT_IDS[i], opt_attributes);\n            if (context) {\n                return /** @type {!WebGLRenderingContext} */ (context);\n            }\n        }\n        catch (e) {\n            // pass\n        }\n    }\n    return null;\n}\n/**\n * @type {Array<string>}\n */\nvar supportedExtensions;\n/**\n * @return {Array<string>} List of supported WebGL extensions.\n */\nexport function getSupportedExtensions() {\n    if (!supportedExtensions) {\n        var canvas = document.createElement('canvas');\n        var gl = getContext(canvas);\n        if (gl) {\n            supportedExtensions = gl.getSupportedExtensions();\n        }\n    }\n    return supportedExtensions;\n}\n//# sourceMappingURL=webgl.js.map","/**\n * @module ol/webgl/Buffer\n */\nimport { ARRAY_BUFFER, ELEMENT_ARRAY_BUFFER } from '../webgl.js';\nimport { DYNAMIC_DRAW, STATIC_DRAW, STREAM_DRAW } from '../webgl.js';\nimport { assert } from '../asserts.js';\n/**\n * Used to describe the intended usage for the data: `STATIC_DRAW`, `STREAM_DRAW`\n * or `DYNAMIC_DRAW`.\n * @enum {number}\n */\nexport var BufferUsage = {\n    STATIC_DRAW: STATIC_DRAW,\n    STREAM_DRAW: STREAM_DRAW,\n    DYNAMIC_DRAW: DYNAMIC_DRAW,\n};\n/**\n * @classdesc\n * Object used to store an array of data as well as usage information for that data.\n * Stores typed arrays internally, either Float32Array or Uint16/32Array depending on\n * the buffer type (ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER) and available extensions.\n *\n * To populate the array, you can either use:\n * * A size using `#ofSize(buffer)`\n * * An `ArrayBuffer` object using `#fromArrayBuffer(buffer)`\n * * A plain array using `#fromArray(array)`\n *\n * Note:\n * See the documentation of [WebGLRenderingContext.bufferData](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/bufferData)\n * for more info on buffer usage.\n * @api\n */\nvar WebGLArrayBuffer = /** @class */ (function () {\n    /**\n     * @param {number} type Buffer type, either ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER.\n     * @param {number} [opt_usage] Intended usage, either `STATIC_DRAW`, `STREAM_DRAW` or `DYNAMIC_DRAW`.\n     * Default is `DYNAMIC_DRAW`.\n     */\n    function WebGLArrayBuffer(type, opt_usage) {\n        /**\n         * @private\n         * @type {Float32Array|Uint32Array}\n         */\n        this.array = null;\n        /**\n         * @private\n         * @type {number}\n         */\n        this.type = type;\n        assert(type === ARRAY_BUFFER || type === ELEMENT_ARRAY_BUFFER, 62);\n        /**\n         * @private\n         * @type {number}\n         */\n        this.usage = opt_usage !== undefined ? opt_usage : BufferUsage.STATIC_DRAW;\n    }\n    /**\n     * Populates the buffer with an array of the given size (all values will be zeroes).\n     * @param {number} size Array size\n     */\n    WebGLArrayBuffer.prototype.ofSize = function (size) {\n        this.array = new (getArrayClassForType(this.type))(size);\n    };\n    /**\n     * Populates the buffer with an array of the given size (all values will be zeroes).\n     * @param {Array<number>} array Numerical array\n     */\n    WebGLArrayBuffer.prototype.fromArray = function (array) {\n        this.array = getArrayClassForType(this.type).from(array);\n    };\n    /**\n     * Populates the buffer with a raw binary array buffer.\n     * @param {ArrayBuffer} buffer Raw binary buffer to populate the array with. Note that this buffer must have been\n     * initialized for the same typed array class.\n     */\n    WebGLArrayBuffer.prototype.fromArrayBuffer = function (buffer) {\n        this.array = new (getArrayClassForType(this.type))(buffer);\n    };\n    /**\n     * @return {number} Buffer type.\n     */\n    WebGLArrayBuffer.prototype.getType = function () {\n        return this.type;\n    };\n    /**\n     * Will return null if the buffer was not initialized\n     * @return {Float32Array|Uint32Array} Array.\n     */\n    WebGLArrayBuffer.prototype.getArray = function () {\n        return this.array;\n    };\n    /**\n     * @return {number} Usage.\n     */\n    WebGLArrayBuffer.prototype.getUsage = function () {\n        return this.usage;\n    };\n    /**\n     * Will return 0 if the buffer is not initialized\n     * @return {number} Array size\n     */\n    WebGLArrayBuffer.prototype.getSize = function () {\n        return this.array ? this.array.length : 0;\n    };\n    return WebGLArrayBuffer;\n}());\n/**\n * Returns a typed array constructor based on the given buffer type\n * @param {number} type Buffer type, either ARRAY_BUFFER or ELEMENT_ARRAY_BUFFER.\n * @return {Float32ArrayConstructor|Uint32ArrayConstructor} The typed array class to use for this buffer.\n */\nexport function getArrayClassForType(type) {\n    switch (type) {\n        case ARRAY_BUFFER:\n            return Float32Array;\n        case ELEMENT_ARRAY_BUFFER:\n            return Uint32Array;\n        default:\n            return Float32Array;\n    }\n}\nexport default WebGLArrayBuffer;\n//# sourceMappingURL=Buffer.js.map","/**\n * @module ol/webgl/ContextEventType\n */\n/**\n * @enum {string}\n */\nexport default {\n    LOST: 'webglcontextlost',\n    RESTORED: 'webglcontextrestored',\n};\n//# sourceMappingURL=ContextEventType.js.map","/**\n * @module ol/webgl/PostProcessingPass\n */\nvar DEFAULT_VERTEX_SHADER = \"\\n  precision mediump float;\\n  \\n  attribute vec2 a_position;\\n  varying vec2 v_texCoord;\\n  varying vec2 v_screenCoord;\\n  \\n  uniform vec2 u_screenSize;\\n   \\n  void main() {\\n    v_texCoord = a_position * 0.5 + 0.5;\\n    v_screenCoord = v_texCoord * u_screenSize;\\n    gl_Position = vec4(a_position, 0.0, 1.0);\\n  }\\n\";\nvar DEFAULT_FRAGMENT_SHADER = \"\\n  precision mediump float;\\n   \\n  uniform sampler2D u_image;\\n   \\n  varying vec2 v_texCoord;\\n   \\n  void main() {\\n    gl_FragColor = texture2D(u_image, v_texCoord);\\n  }\\n\";\n/**\n * @typedef {Object} Options\n * @property {WebGLRenderingContext} webGlContext WebGL context; mandatory.\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas that will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object<string,import(\"./Helper\").UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n/**\n * @typedef {Object} UniformInternalDescription\n * @property {import(\"./Helper\").UniformValue} value Value\n * @property {number} location Location\n * @property {WebGLTexture} [texture] Texture\n * @private\n */\n/**\n * @classdesc\n * This class is used to define Post Processing passes with custom shaders and uniforms.\n * This is used internally by {@link module:ol/webgl/Helper~WebGLHelper}.\n *\n * Please note that the final output on the DOM canvas is expected to have premultiplied alpha, which means that\n * a pixel which is 100% red with an opacity of 50% must have a color of (r=0.5, g=0, b=0, a=0.5).\n * Failing to provide pixel colors with premultiplied alpha will result in render anomalies.\n *\n * The default post-processing pass does *not* multiply color values with alpha value, it expects color values to be\n * premultiplied.\n *\n * Default shaders are shown hereafter:\n *\n * * Vertex shader:\n *\n *   ```\n *   precision mediump float;\n *\n *   attribute vec2 a_position;\n *   varying vec2 v_texCoord;\n *   varying vec2 v_screenCoord;\n *\n *   uniform vec2 u_screenSize;\n *\n *   void main() {\n *     v_texCoord = a_position * 0.5 + 0.5;\n *     v_screenCoord = v_texCoord * u_screenSize;\n *     gl_Position = vec4(a_position, 0.0, 1.0);\n *   }\n *   ```\n *\n * * Fragment shader:\n *\n *   ```\n *   precision mediump float;\n *\n *   uniform sampler2D u_image;\n *\n *   varying vec2 v_texCoord;\n *\n *   void main() {\n *     gl_FragColor = texture2D(u_image, v_texCoord);\n *   }\n *   ```\n *\n * @api\n */\nvar WebGLPostProcessingPass = /** @class */ (function () {\n    /**\n     * @param {Options} options Options.\n     */\n    function WebGLPostProcessingPass(options) {\n        this.gl_ = options.webGlContext;\n        var gl = this.gl_;\n        this.scaleRatio_ = options.scaleRatio || 1;\n        this.renderTargetTexture_ = gl.createTexture();\n        this.renderTargetTextureSize_ = null;\n        this.frameBuffer_ = gl.createFramebuffer();\n        // compile the program for the frame buffer\n        // TODO: make compilation errors show up\n        var vertexShader = gl.createShader(gl.VERTEX_SHADER);\n        gl.shaderSource(vertexShader, options.vertexShader || DEFAULT_VERTEX_SHADER);\n        gl.compileShader(vertexShader);\n        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n        gl.shaderSource(fragmentShader, options.fragmentShader || DEFAULT_FRAGMENT_SHADER);\n        gl.compileShader(fragmentShader);\n        this.renderTargetProgram_ = gl.createProgram();\n        gl.attachShader(this.renderTargetProgram_, vertexShader);\n        gl.attachShader(this.renderTargetProgram_, fragmentShader);\n        gl.linkProgram(this.renderTargetProgram_);\n        // bind the vertices buffer for the frame buffer\n        this.renderTargetVerticesBuffer_ = gl.createBuffer();\n        var verticesArray = [-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1];\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesArray), gl.STATIC_DRAW);\n        this.renderTargetAttribLocation_ = gl.getAttribLocation(this.renderTargetProgram_, 'a_position');\n        this.renderTargetUniformLocation_ = gl.getUniformLocation(this.renderTargetProgram_, 'u_screenSize');\n        this.renderTargetTextureLocation_ = gl.getUniformLocation(this.renderTargetProgram_, 'u_image');\n        /**\n         * Holds info about custom uniforms used in the post processing pass\n         * @type {Array<UniformInternalDescription>}\n         * @private\n         */\n        this.uniforms_ = [];\n        options.uniforms &&\n            Object.keys(options.uniforms).forEach(function (name) {\n                this.uniforms_.push({\n                    value: options.uniforms[name],\n                    location: gl.getUniformLocation(this.renderTargetProgram_, name),\n                });\n            }.bind(this));\n    }\n    /**\n     * Get the WebGL rendering context\n     * @return {WebGLRenderingContext} The rendering context.\n     * @api\n     */\n    WebGLPostProcessingPass.prototype.getGL = function () {\n        return this.gl_;\n    };\n    /**\n     * Initialize the render target texture of the post process, make sure it is at the\n     * right size and bind it as a render target for the next draw calls.\n     * The last step to be initialized will be the one where the primitives are rendered.\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState current frame state\n     * @api\n     */\n    WebGLPostProcessingPass.prototype.init = function (frameState) {\n        var gl = this.getGL();\n        var textureSize = [\n            gl.drawingBufferWidth * this.scaleRatio_,\n            gl.drawingBufferHeight * this.scaleRatio_,\n        ];\n        // rendering goes to my buffer\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this.getFrameBuffer());\n        gl.viewport(0, 0, textureSize[0], textureSize[1]);\n        // if size has changed: adjust canvas & render target texture\n        if (!this.renderTargetTextureSize_ ||\n            this.renderTargetTextureSize_[0] !== textureSize[0] ||\n            this.renderTargetTextureSize_[1] !== textureSize[1]) {\n            this.renderTargetTextureSize_ = textureSize;\n            // create a new texture\n            var level = 0;\n            var internalFormat = gl.RGBA;\n            var border = 0;\n            var format = gl.RGBA;\n            var type = gl.UNSIGNED_BYTE;\n            var data = null;\n            gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);\n            gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, textureSize[0], textureSize[1], border, format, type, data);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            // bind the texture to the framebuffer\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.renderTargetTexture_, 0);\n        }\n    };\n    /**\n     * Render to the next postprocessing pass (or to the canvas if final pass).\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState current frame state\n     * @param {WebGLPostProcessingPass} [nextPass] Next pass, optional\n     * @api\n     */\n    WebGLPostProcessingPass.prototype.apply = function (frameState, nextPass) {\n        var gl = this.getGL();\n        var size = frameState.size;\n        gl.bindFramebuffer(gl.FRAMEBUFFER, nextPass ? nextPass.getFrameBuffer() : null);\n        gl.activeTexture(gl.TEXTURE0);\n        gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);\n        // render the frame buffer to the canvas\n        gl.clearColor(0.0, 0.0, 0.0, 0.0);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n        gl.enable(gl.BLEND);\n        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);\n        gl.useProgram(this.renderTargetProgram_);\n        gl.enableVertexAttribArray(this.renderTargetAttribLocation_);\n        gl.vertexAttribPointer(this.renderTargetAttribLocation_, 2, gl.FLOAT, false, 0, 0);\n        gl.uniform2f(this.renderTargetUniformLocation_, size[0], size[1]);\n        gl.uniform1i(this.renderTargetTextureLocation_, 0);\n        this.applyUniforms(frameState);\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\n    };\n    /**\n     * @return {WebGLFramebuffer} Frame buffer\n     * @api\n     */\n    WebGLPostProcessingPass.prototype.getFrameBuffer = function () {\n        return this.frameBuffer_;\n    };\n    /**\n     * Sets the custom uniforms based on what was given in the constructor.\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n     * @private\n     */\n    WebGLPostProcessingPass.prototype.applyUniforms = function (frameState) {\n        var gl = this.getGL();\n        var value;\n        var textureSlot = 1;\n        this.uniforms_.forEach(function (uniform) {\n            value =\n                typeof uniform.value === 'function'\n                    ? uniform.value(frameState)\n                    : uniform.value;\n            // apply value based on type\n            if (value instanceof HTMLCanvasElement || value instanceof ImageData) {\n                // create a texture & put data\n                if (!uniform.texture) {\n                    uniform.texture = gl.createTexture();\n                }\n                gl.activeTexture(gl[\"TEXTURE\" + textureSlot]);\n                gl.bindTexture(gl.TEXTURE_2D, uniform.texture);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                if (value instanceof ImageData) {\n                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, value.width, value.height, 0, gl.UNSIGNED_BYTE, new Uint8Array(value.data));\n                }\n                else {\n                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value);\n                }\n                // fill texture slots\n                gl.uniform1i(uniform.location, textureSlot++);\n            }\n            else if (Array.isArray(value)) {\n                switch (value.length) {\n                    case 2:\n                        gl.uniform2f(uniform.location, value[0], value[1]);\n                        return;\n                    case 3:\n                        gl.uniform3f(uniform.location, value[0], value[1], value[2]);\n                        return;\n                    case 4:\n                        gl.uniform4f(uniform.location, value[0], value[1], value[2], value[3]);\n                        return;\n                    default:\n                        return;\n                }\n            }\n            else if (typeof value === 'number') {\n                gl.uniform1f(uniform.location, value);\n            }\n        });\n    };\n    return WebGLPostProcessingPass;\n}());\nexport default WebGLPostProcessingPass;\n//# sourceMappingURL=PostProcessingPass.js.map","/**\n * @module ol/vec/mat4\n */\n/**\n * @return {Array<number>} \"4x4 matrix representing a 3D identity transform.\"\n */\nexport function create() {\n    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\n/**\n * @param {Array<number>} mat4 Flattened 4x4 matrix receiving the result.\n * @param {import(\"../transform.js\").Transform} transform Transformation matrix.\n * @return {Array<number>} \"2D transformation matrix as flattened 4x4 matrix.\"\n */\nexport function fromTransform(mat4, transform) {\n    mat4[0] = transform[0];\n    mat4[1] = transform[1];\n    mat4[4] = transform[2];\n    mat4[5] = transform[3];\n    mat4[12] = transform[4];\n    mat4[13] = transform[5];\n    return mat4;\n}\n//# sourceMappingURL=mat4.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/webgl/Helper\n */\nimport ContextEventType from '../webgl/ContextEventType.js';\nimport Disposable from '../Disposable.js';\nimport WebGLPostProcessingPass from './PostProcessingPass.js';\nimport { FLOAT, UNSIGNED_BYTE, UNSIGNED_INT, UNSIGNED_SHORT, getContext, getSupportedExtensions, } from '../webgl.js';\nimport { assert } from '../asserts.js';\nimport { clear } from '../obj.js';\nimport { compose as composeTransform, create as createTransform, reset as resetTransform, rotate as rotateTransform, scale as scaleTransform, } from '../transform.js';\nimport { create, fromTransform } from '../vec/mat4.js';\nimport { getUid } from '../util.js';\nimport { includes } from '../array.js';\n/**\n * @typedef {Object} BufferCacheEntry\n * @property {import(\"./Buffer.js\").default} buffer Buffer.\n * @property {WebGLBuffer} webGlBuffer WebGlBuffer.\n */\n/**\n * Shader types, either `FRAGMENT_SHADER` or `VERTEX_SHADER`.\n * @enum {number}\n */\nexport var ShaderType = {\n    FRAGMENT_SHADER: 0x8b30,\n    VERTEX_SHADER: 0x8b31,\n};\n/**\n * Uniform names used in the default shaders: `PROJECTION_MATRIX`, `OFFSET_SCALE_MATRIX`.\n * and `OFFSET_ROTATION_MATRIX`.\n * @enum {string}\n */\nexport var DefaultUniform = {\n    PROJECTION_MATRIX: 'u_projectionMatrix',\n    OFFSET_SCALE_MATRIX: 'u_offsetScaleMatrix',\n    OFFSET_ROTATION_MATRIX: 'u_offsetRotateMatrix',\n    TIME: 'u_time',\n    ZOOM: 'u_zoom',\n    RESOLUTION: 'u_resolution',\n};\n/**\n * Attribute types, either `UNSIGNED_BYTE`, `UNSIGNED_SHORT`, `UNSIGNED_INT` or `FLOAT`\n * Note: an attribute stored in a `Float32Array` should be of type `FLOAT`.\n * @enum {number}\n */\nexport var AttributeType = {\n    UNSIGNED_BYTE: UNSIGNED_BYTE,\n    UNSIGNED_SHORT: UNSIGNED_SHORT,\n    UNSIGNED_INT: UNSIGNED_INT,\n    FLOAT: FLOAT,\n};\n/**\n * Description of an attribute in a buffer\n * @typedef {Object} AttributeDescription\n * @property {string} name Attribute name to use in shaders\n * @property {number} size Number of components per attributes\n * @property {AttributeType} [type] Attribute type, i.e. number of bytes used to store the value. This is\n * determined by the class of typed array which the buffer uses (eg. `Float32Array` for a `FLOAT` attribute).\n * Default is `FLOAT`.\n */\n/**\n * @typedef {number|Array<number>|HTMLCanvasElement|HTMLImageElement|ImageData|import(\"../transform\").Transform} UniformLiteralValue\n */\n/**\n * Uniform value can be a number, array of numbers (2 to 4), canvas element or a callback returning\n * one of the previous types.\n * @typedef {UniformLiteralValue|function(import(\"../PluggableMap.js\").FrameState):UniformLiteralValue} UniformValue\n */\n/**\n * @typedef {Object} PostProcessesOptions\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas which will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object<string,UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n/**\n * @typedef {Object} Options\n * @property {Object<string,UniformValue>} [uniforms] Uniform definitions; property names must match the uniform\n * names in the provided or default shaders.\n * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n/**\n * @typedef {Object} UniformInternalDescription\n * @property {string} name Name\n * @property {UniformValue} [value] Value\n * @property {WebGLTexture} [texture] Texture\n * @private\n */\n/**\n * @classdesc\n * This class is intended to provide low-level functions related to WebGL rendering, so that accessing\n * directly the WebGL API should not be required anymore.\n *\n * Several operations are handled by the `WebGLHelper` class:\n *\n * ### Define custom shaders and uniforms\n *\n *   *Shaders* are low-level programs executed on the GPU and written in GLSL. There are two types of shaders:\n *\n *   Vertex shaders are used to manipulate the position and attribute of *vertices* of rendered primitives (ie. corners of a square).\n *   Outputs are:\n *\n *   * `gl_Position`: position of the vertex in screen space\n *\n *   * Varyings usually prefixed with `v_` are passed on to the fragment shader\n *\n *   Fragment shaders are used to control the actual color of the pixels drawn on screen. Their only output is `gl_FragColor`.\n *\n *   Both shaders can take *uniforms* or *attributes* as input. Attributes are explained later. Uniforms are common, read-only values that\n *   can be changed at every frame and can be of type float, arrays of float or images.\n *\n *   Shaders must be compiled and assembled into a program like so:\n *   ```js\n *   // here we simply create two shaders and assemble them in a program which is then used\n *   // for subsequent rendering calls\n *   const vertexShader = new WebGLVertex(VERTEX_SHADER);\n *   const fragmentShader = new WebGLFragment(FRAGMENT_SHADER);\n *   const program = this.context.getProgram(fragmentShader, vertexShader);\n *   helper.useProgram(this.program);\n *   ```\n *\n *   Uniforms are defined using the `uniforms` option and can either be explicit values or callbacks taking the frame state as argument.\n *   You can also change their value along the way like so:\n *   ```js\n *   helper.setUniformFloatValue('u_value', valueAsNumber);\n *   ```\n *\n * ### Defining post processing passes\n *\n *   *Post processing* describes the act of rendering primitives to a texture, and then rendering this texture to the final canvas\n *   while applying special effects in screen space.\n *   Typical uses are: blurring, color manipulation, depth of field, filtering...\n *\n *   The `WebGLHelper` class offers the possibility to define post processes at creation time using the `postProcesses` option.\n *   A post process step accepts the following options:\n *\n *   * `fragmentShader` and `vertexShader`: text literals in GLSL language that will be compiled and used in the post processing step.\n *   * `uniforms`: uniforms can be defined for the post processing steps just like for the main render.\n *   * `scaleRatio`: allows using an intermediate texture smaller or higher than the final canvas in the post processing step.\n *     This is typically used in blur steps to reduce the performance overhead by using an already downsampled texture as input.\n *\n *   The {@link module:ol/webgl/PostProcessingPass~WebGLPostProcessingPass} class is used internally, refer to its documentation for more info.\n *\n * ### Binding WebGL buffers and flushing data into them\n *\n *   Data that must be passed to the GPU has to be transferred using {@link module:ol/webgl/Buffer~WebGLArrayBuffer} objects.\n *   A buffer has to be created only once, but must be bound every time the buffer content will be used for rendering.\n *   This is done using {@link bindBuffer}.\n *   When the buffer's array content has changed, the new data has to be flushed to the GPU memory; this is done using\n *   {@link flushBufferData}. Note: this operation is expensive and should be done as infrequently as possible.\n *\n *   When binding an array buffer, a `target` parameter must be given: it should be either {@link module:ol/webgl.ARRAY_BUFFER}\n *   (if the buffer contains vertices data) or {@link module:ol/webgl.ELEMENT_ARRAY_BUFFER} (if the buffer contains indices data).\n *\n *   Examples below:\n *   ```js\n *   // at initialization phase\n *   const verticesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);\n *   const indicesBuffer = new WebGLArrayBuffer([], DYNAMIC_DRAW);\n *\n *   // when array values have changed\n *   helper.flushBufferData(ARRAY_BUFFER, this.verticesBuffer);\n *   helper.flushBufferData(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n *\n *   // at rendering phase\n *   helper.bindBuffer(ARRAY_BUFFER, this.verticesBuffer);\n *   helper.bindBuffer(ELEMENT_ARRAY_BUFFER, this.indicesBuffer);\n *   ```\n *\n * ### Specifying attributes\n *\n *   The GPU only receives the data as arrays of numbers. These numbers must be handled differently depending on what it describes (position, texture coordinate...).\n *   Attributes are used to specify these uses. Use {@link enableAttributeArray_} and either\n *   the default attribute names in {@link module:ol/webgl/Helper.DefaultAttrib} or custom ones.\n *\n *   Please note that you will have to specify the type and offset of the attributes in the data array. You can refer to the documentation of [WebGLRenderingContext.vertexAttribPointer](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer) for more explanation.\n *   ```js\n *   // here we indicate that the data array has the following structure:\n *   // [posX, posY, offsetX, offsetY, texCoordU, texCoordV, posX, posY, ...]\n *   helper.enableAttributes([\n *     {\n *        name: 'a_position',\n *        size: 2\n *     },\n *     {\n *       name: 'a_offset',\n *       size: 2\n *     },\n *     {\n *       name: 'a_texCoord',\n *       size: 2\n *     }\n *   ])\n *   ```\n *\n * ### Rendering primitives\n *\n *   Once all the steps above have been achieved, rendering primitives to the screen is done using {@link prepareDraw}, {@link drawElements} and {@link finalizeDraw}.\n *   ```js\n *   // frame preparation step\n *   helper.prepareDraw(frameState);\n *\n *   // call this for every data array that has to be rendered on screen\n *   helper.drawElements(0, this.indicesBuffer.getArray().length);\n *\n *   // finalize the rendering by applying post processes\n *   helper.finalizeDraw(frameState);\n *   ```\n *\n * For an example usage of this class, refer to {@link module:ol/renderer/webgl/PointsLayer~WebGLPointsLayerRenderer}.\n *\n *\n * @api\n */\nvar WebGLHelper = /** @class */ (function (_super) {\n    __extends(WebGLHelper, _super);\n    /**\n     * @param {Options} [opt_options] Options.\n     */\n    function WebGLHelper(opt_options) {\n        var _this = _super.call(this) || this;\n        var options = opt_options || {};\n        /** @private */\n        _this.boundHandleWebGLContextLost_ = _this.handleWebGLContextLost.bind(_this);\n        /** @private */\n        _this.boundHandleWebGLContextRestored_ =\n            _this.handleWebGLContextRestored.bind(_this);\n        /**\n         * @private\n         * @type {HTMLCanvasElement}\n         */\n        _this.canvas_ = document.createElement('canvas');\n        _this.canvas_.style.position = 'absolute';\n        _this.canvas_.style.left = '0';\n        /**\n         * @private\n         * @type {WebGLRenderingContext}\n         */\n        _this.gl_ = getContext(_this.canvas_);\n        var gl = _this.getGL();\n        /**\n         * @private\n         * @type {!Object<string, BufferCacheEntry>}\n         */\n        _this.bufferCache_ = {};\n        /**\n         * @private\n         * @type {WebGLProgram}\n         */\n        _this.currentProgram_ = null;\n        assert(includes(getSupportedExtensions(), 'OES_element_index_uint'), 63);\n        gl.getExtension('OES_element_index_uint');\n        _this.canvas_.addEventListener(ContextEventType.LOST, _this.boundHandleWebGLContextLost_);\n        _this.canvas_.addEventListener(ContextEventType.RESTORED, _this.boundHandleWebGLContextRestored_);\n        /**\n         * @private\n         * @type {import(\"../transform.js\").Transform}\n         */\n        _this.offsetRotateMatrix_ = createTransform();\n        /**\n         * @private\n         * @type {import(\"../transform.js\").Transform}\n         */\n        _this.offsetScaleMatrix_ = createTransform();\n        /**\n         * @private\n         * @type {Array<number>}\n         */\n        _this.tmpMat4_ = create();\n        /**\n         * @private\n         * @type {Object<string, WebGLUniformLocation>}\n         */\n        _this.uniformLocations_ = {};\n        /**\n         * @private\n         * @type {Object<string, number>}\n         */\n        _this.attribLocations_ = {};\n        /**\n         * Holds info about custom uniforms used in the post processing pass.\n         * If the uniform is a texture, the WebGL Texture object will be stored here.\n         * @type {Array<UniformInternalDescription>}\n         * @private\n         */\n        _this.uniforms_ = [];\n        if (options.uniforms) {\n            for (var name_1 in options.uniforms) {\n                _this.uniforms_.push({\n                    name: name_1,\n                    value: options.uniforms[name_1],\n                });\n            }\n        }\n        /**\n         * An array of PostProcessingPass objects is kept in this variable, built from the steps provided in the\n         * options. If no post process was given, a default one is used (so as not to have to make an exception to\n         * the frame buffer logic).\n         * @type {Array<WebGLPostProcessingPass>}\n         * @private\n         */\n        _this.postProcessPasses_ = options.postProcesses\n            ? options.postProcesses.map(function (options) {\n                return new WebGLPostProcessingPass({\n                    webGlContext: gl,\n                    scaleRatio: options.scaleRatio,\n                    vertexShader: options.vertexShader,\n                    fragmentShader: options.fragmentShader,\n                    uniforms: options.uniforms,\n                });\n            })\n            : [new WebGLPostProcessingPass({ webGlContext: gl })];\n        /**\n         * @type {string|null}\n         * @private\n         */\n        _this.shaderCompileErrors_ = null;\n        /**\n         * @type {number}\n         * @private\n         */\n        _this.startTime_ = Date.now();\n        return _this;\n    }\n    /**\n     * Just bind the buffer if it's in the cache. Otherwise create\n     * the WebGL buffer, bind it, populate it, and add an entry to\n     * the cache.\n     * @param {import(\"./Buffer\").default} buffer Buffer.\n     * @api\n     */\n    WebGLHelper.prototype.bindBuffer = function (buffer) {\n        var gl = this.getGL();\n        var bufferKey = getUid(buffer);\n        var bufferCache = this.bufferCache_[bufferKey];\n        if (!bufferCache) {\n            var webGlBuffer = gl.createBuffer();\n            bufferCache = {\n                buffer: buffer,\n                webGlBuffer: webGlBuffer,\n            };\n            this.bufferCache_[bufferKey] = bufferCache;\n        }\n        gl.bindBuffer(buffer.getType(), bufferCache.webGlBuffer);\n    };\n    /**\n     * Update the data contained in the buffer array; this is required for the\n     * new data to be rendered\n     * @param {import(\"./Buffer\").default} buffer Buffer.\n     * @api\n     */\n    WebGLHelper.prototype.flushBufferData = function (buffer) {\n        var gl = this.getGL();\n        this.bindBuffer(buffer);\n        gl.bufferData(buffer.getType(), buffer.getArray(), buffer.getUsage());\n    };\n    /**\n     * @param {import(\"./Buffer.js\").default} buf Buffer.\n     */\n    WebGLHelper.prototype.deleteBuffer = function (buf) {\n        var gl = this.getGL();\n        var bufferKey = getUid(buf);\n        var bufferCacheEntry = this.bufferCache_[bufferKey];\n        if (bufferCacheEntry && !gl.isContextLost()) {\n            gl.deleteBuffer(bufferCacheEntry.webGlBuffer);\n        }\n        delete this.bufferCache_[bufferKey];\n    };\n    /**\n     * Clean up.\n     */\n    WebGLHelper.prototype.disposeInternal = function () {\n        this.canvas_.removeEventListener(ContextEventType.LOST, this.boundHandleWebGLContextLost_);\n        this.canvas_.removeEventListener(ContextEventType.RESTORED, this.boundHandleWebGLContextRestored_);\n    };\n    /**\n     * Clear the buffer & set the viewport to draw.\n     * Post process passes will be initialized here, the first one being bound as a render target for\n     * subsequent draw calls.\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState current frame state\n     * @param {boolean} [opt_disableAlphaBlend] If true, no alpha blending will happen.\n     * @api\n     */\n    WebGLHelper.prototype.prepareDraw = function (frameState, opt_disableAlphaBlend) {\n        var gl = this.getGL();\n        var canvas = this.getCanvas();\n        var size = frameState.size;\n        var pixelRatio = frameState.pixelRatio;\n        canvas.width = size[0] * pixelRatio;\n        canvas.height = size[1] * pixelRatio;\n        canvas.style.width = size[0] + 'px';\n        canvas.style.height = size[1] + 'px';\n        gl.useProgram(this.currentProgram_);\n        // loop backwards in post processes list\n        for (var i = this.postProcessPasses_.length - 1; i >= 0; i--) {\n            this.postProcessPasses_[i].init(frameState);\n        }\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        gl.clearColor(0.0, 0.0, 0.0, 0.0);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n        gl.enable(gl.BLEND);\n        gl.blendFunc(gl.ONE, opt_disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);\n        gl.useProgram(this.currentProgram_);\n        this.applyFrameState(frameState);\n        this.applyUniforms(frameState);\n    };\n    /**\n     * Clear the render target & bind it for future draw operations.\n     * This is similar to `prepareDraw`, only post processes will not be applied.\n     * Note: the whole viewport will be drawn to the render target, regardless of its size.\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState current frame state\n     * @param {import(\"./RenderTarget.js\").default} renderTarget Render target to draw to\n     * @param {boolean} [opt_disableAlphaBlend] If true, no alpha blending will happen.\n     */\n    WebGLHelper.prototype.prepareDrawToRenderTarget = function (frameState, renderTarget, opt_disableAlphaBlend) {\n        var gl = this.getGL();\n        var size = renderTarget.getSize();\n        gl.bindFramebuffer(gl.FRAMEBUFFER, renderTarget.getFramebuffer());\n        gl.viewport(0, 0, size[0], size[1]);\n        gl.bindTexture(gl.TEXTURE_2D, renderTarget.getTexture());\n        gl.clearColor(0.0, 0.0, 0.0, 0.0);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n        gl.enable(gl.BLEND);\n        gl.blendFunc(gl.ONE, opt_disableAlphaBlend ? gl.ZERO : gl.ONE_MINUS_SRC_ALPHA);\n        gl.useProgram(this.currentProgram_);\n        this.applyFrameState(frameState);\n        this.applyUniforms(frameState);\n    };\n    /**\n     * Execute a draw call based on the currently bound program, texture, buffers, attributes.\n     * @param {number} start Start index.\n     * @param {number} end End index.\n     * @api\n     */\n    WebGLHelper.prototype.drawElements = function (start, end) {\n        var gl = this.getGL();\n        var elementType = gl.UNSIGNED_INT;\n        var elementSize = 4;\n        var numItems = end - start;\n        var offsetInBytes = start * elementSize;\n        gl.drawElements(gl.TRIANGLES, numItems, elementType, offsetInBytes);\n    };\n    /**\n     * Apply the successive post process passes which will eventually render to the actual canvas.\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState current frame state\n     * @api\n     */\n    WebGLHelper.prototype.finalizeDraw = function (frameState) {\n        // apply post processes using the next one as target\n        for (var i = 0; i < this.postProcessPasses_.length; i++) {\n            this.postProcessPasses_[i].apply(frameState, this.postProcessPasses_[i + 1] || null);\n        }\n    };\n    /**\n     * @return {HTMLCanvasElement} Canvas.\n     * @api\n     */\n    WebGLHelper.prototype.getCanvas = function () {\n        return this.canvas_;\n    };\n    /**\n     * Get the WebGL rendering context\n     * @return {WebGLRenderingContext} The rendering context.\n     * @api\n     */\n    WebGLHelper.prototype.getGL = function () {\n        return this.gl_;\n    };\n    /**\n     * Sets the default matrix uniforms for a given frame state. This is called internally in `prepareDraw`.\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n     * @private\n     */\n    WebGLHelper.prototype.applyFrameState = function (frameState) {\n        var size = frameState.size;\n        var rotation = frameState.viewState.rotation;\n        var offsetScaleMatrix = resetTransform(this.offsetScaleMatrix_);\n        scaleTransform(offsetScaleMatrix, 2 / size[0], 2 / size[1]);\n        var offsetRotateMatrix = resetTransform(this.offsetRotateMatrix_);\n        if (rotation !== 0) {\n            rotateTransform(offsetRotateMatrix, -rotation);\n        }\n        this.setUniformMatrixValue(DefaultUniform.OFFSET_SCALE_MATRIX, fromTransform(this.tmpMat4_, offsetScaleMatrix));\n        this.setUniformMatrixValue(DefaultUniform.OFFSET_ROTATION_MATRIX, fromTransform(this.tmpMat4_, offsetRotateMatrix));\n        this.setUniformFloatValue(DefaultUniform.TIME, (Date.now() - this.startTime_) * 0.001);\n        this.setUniformFloatValue(DefaultUniform.ZOOM, frameState.viewState.zoom);\n        this.setUniformFloatValue(DefaultUniform.RESOLUTION, frameState.viewState.resolution);\n    };\n    /**\n     * Sets the custom uniforms based on what was given in the constructor. This is called internally in `prepareDraw`.\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n     * @private\n     */\n    WebGLHelper.prototype.applyUniforms = function (frameState) {\n        var gl = this.getGL();\n        var value;\n        var textureSlot = 0;\n        this.uniforms_.forEach(function (uniform) {\n            value =\n                typeof uniform.value === 'function'\n                    ? uniform.value(frameState)\n                    : uniform.value;\n            // apply value based on type\n            if (value instanceof HTMLCanvasElement ||\n                value instanceof HTMLImageElement ||\n                value instanceof ImageData) {\n                // create a texture & put data\n                if (!uniform.texture) {\n                    uniform.prevValue = undefined;\n                    uniform.texture = gl.createTexture();\n                }\n                gl.activeTexture(gl[\"TEXTURE\" + textureSlot]);\n                gl.bindTexture(gl.TEXTURE_2D, uniform.texture);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                var imageReady = !(value instanceof HTMLImageElement) ||\n                    /** @type {HTMLImageElement} */ (value).complete;\n                if (imageReady && uniform.prevValue !== value) {\n                    uniform.prevValue = value;\n                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value);\n                }\n                // fill texture slots by increasing index\n                gl.uniform1i(this.getUniformLocation(uniform.name), textureSlot++);\n            }\n            else if (Array.isArray(value) && value.length === 6) {\n                this.setUniformMatrixValue(uniform.name, fromTransform(this.tmpMat4_, value));\n            }\n            else if (Array.isArray(value) && value.length <= 4) {\n                switch (value.length) {\n                    case 2:\n                        gl.uniform2f(this.getUniformLocation(uniform.name), value[0], value[1]);\n                        return;\n                    case 3:\n                        gl.uniform3f(this.getUniformLocation(uniform.name), value[0], value[1], value[2]);\n                        return;\n                    case 4:\n                        gl.uniform4f(this.getUniformLocation(uniform.name), value[0], value[1], value[2], value[3]);\n                        return;\n                    default:\n                        return;\n                }\n            }\n            else if (typeof value === 'number') {\n                gl.uniform1f(this.getUniformLocation(uniform.name), value);\n            }\n        }.bind(this));\n    };\n    /**\n     * Use a program.  If the program is already in use, this will return `false`.\n     * @param {WebGLProgram} program Program.\n     * @return {boolean} Changed.\n     * @api\n     */\n    WebGLHelper.prototype.useProgram = function (program) {\n        if (program == this.currentProgram_) {\n            return false;\n        }\n        else {\n            var gl = this.getGL();\n            gl.useProgram(program);\n            this.currentProgram_ = program;\n            this.uniformLocations_ = {};\n            this.attribLocations_ = {};\n            return true;\n        }\n    };\n    /**\n     * Will attempt to compile a vertex or fragment shader based on source\n     * On error, the shader will be returned but\n     * `gl.getShaderParameter(shader, gl.COMPILE_STATUS)` will return `true`\n     * Use `gl.getShaderInfoLog(shader)` to have details\n     * @param {string} source Shader source\n     * @param {ShaderType} type VERTEX_SHADER or FRAGMENT_SHADER\n     * @return {WebGLShader} Shader object\n     */\n    WebGLHelper.prototype.compileShader = function (source, type) {\n        var gl = this.getGL();\n        var shader = gl.createShader(type);\n        gl.shaderSource(shader, source);\n        gl.compileShader(shader);\n        return shader;\n    };\n    /**\n     * Create a program for a vertex and fragment shader.  Throws if shader compilation fails.\n     * @param {string} fragmentShaderSource Fragment shader source.\n     * @param {string} vertexShaderSource Vertex shader source.\n     * @return {WebGLProgram} Program\n     * @api\n     */\n    WebGLHelper.prototype.getProgram = function (fragmentShaderSource, vertexShaderSource) {\n        var gl = this.getGL();\n        var fragmentShader = this.compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);\n        var vertexShader = this.compileShader(vertexShaderSource, gl.VERTEX_SHADER);\n        var program = gl.createProgram();\n        gl.attachShader(program, fragmentShader);\n        gl.attachShader(program, vertexShader);\n        gl.linkProgram(program);\n        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n            var message = \"Fragment shader compliation failed: \" + gl.getShaderInfoLog(fragmentShader);\n            throw new Error(message);\n        }\n        gl.deleteShader(fragmentShader);\n        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n            var message = \"Vertex shader compilation failed: \" + gl.getShaderInfoLog(vertexShader);\n            throw new Error(message);\n        }\n        gl.deleteShader(vertexShader);\n        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n            var message = \"GL program linking failed: \" + gl.getShaderInfoLog(vertexShader);\n            throw new Error(message);\n        }\n        return program;\n    };\n    /**\n     * Will get the location from the shader or the cache\n     * @param {string} name Uniform name\n     * @return {WebGLUniformLocation} uniformLocation\n     * @api\n     */\n    WebGLHelper.prototype.getUniformLocation = function (name) {\n        if (this.uniformLocations_[name] === undefined) {\n            this.uniformLocations_[name] = this.getGL().getUniformLocation(this.currentProgram_, name);\n        }\n        return this.uniformLocations_[name];\n    };\n    /**\n     * Will get the location from the shader or the cache\n     * @param {string} name Attribute name\n     * @return {number} attribLocation\n     * @api\n     */\n    WebGLHelper.prototype.getAttributeLocation = function (name) {\n        if (this.attribLocations_[name] === undefined) {\n            this.attribLocations_[name] = this.getGL().getAttribLocation(this.currentProgram_, name);\n        }\n        return this.attribLocations_[name];\n    };\n    /**\n     * Modifies the given transform to apply the rotation/translation/scaling of the given frame state.\n     * The resulting transform can be used to convert world space coordinates to view coordinates.\n     * @param {import(\"../PluggableMap.js\").FrameState} frameState Frame state.\n     * @param {import(\"../transform\").Transform} transform Transform to update.\n     * @return {import(\"../transform\").Transform} The updated transform object.\n     * @api\n     */\n    WebGLHelper.prototype.makeProjectionTransform = function (frameState, transform) {\n        var size = frameState.size;\n        var rotation = frameState.viewState.rotation;\n        var resolution = frameState.viewState.resolution;\n        var center = frameState.viewState.center;\n        resetTransform(transform);\n        composeTransform(transform, 0, 0, 2 / (resolution * size[0]), 2 / (resolution * size[1]), -rotation, -center[0], -center[1]);\n        return transform;\n    };\n    /**\n     * Give a value for a standard float uniform\n     * @param {string} uniform Uniform name\n     * @param {number} value Value\n     * @api\n     */\n    WebGLHelper.prototype.setUniformFloatValue = function (uniform, value) {\n        this.getGL().uniform1f(this.getUniformLocation(uniform), value);\n    };\n    /**\n     * Give a value for a standard matrix4 uniform\n     * @param {string} uniform Uniform name\n     * @param {Array<number>} value Matrix value\n     * @api\n     */\n    WebGLHelper.prototype.setUniformMatrixValue = function (uniform, value) {\n        this.getGL().uniformMatrix4fv(this.getUniformLocation(uniform), false, value);\n    };\n    /**\n     * Will set the currently bound buffer to an attribute of the shader program. Used by `#enableAttributes`\n     * internally.\n     * @param {string} attribName Attribute name\n     * @param {number} size Number of components per attributes\n     * @param {number} type UNSIGNED_INT, UNSIGNED_BYTE, UNSIGNED_SHORT or FLOAT\n     * @param {number} stride Stride in bytes (0 means attribs are packed)\n     * @param {number} offset Offset in bytes\n     * @private\n     */\n    WebGLHelper.prototype.enableAttributeArray_ = function (attribName, size, type, stride, offset) {\n        var location = this.getAttributeLocation(attribName);\n        // the attribute has not been found in the shaders; do not enable it\n        if (location < 0) {\n            return;\n        }\n        this.getGL().enableVertexAttribArray(location);\n        this.getGL().vertexAttribPointer(location, size, type, false, stride, offset);\n    };\n    /**\n     * Will enable the following attributes to be read from the currently bound buffer,\n     * i.e. tell the GPU where to read the different attributes in the buffer. An error in the\n     * size/type/order of attributes will most likely break the rendering and throw a WebGL exception.\n     * @param {Array<AttributeDescription>} attributes Ordered list of attributes to read from the buffer\n     * @api\n     */\n    WebGLHelper.prototype.enableAttributes = function (attributes) {\n        var stride = computeAttributesStride(attributes);\n        var offset = 0;\n        for (var i = 0; i < attributes.length; i++) {\n            var attr = attributes[i];\n            this.enableAttributeArray_(attr.name, attr.size, attr.type || FLOAT, stride, offset);\n            offset += attr.size * getByteSizeFromType(attr.type);\n        }\n    };\n    /**\n     * WebGL context was lost\n     * @private\n     */\n    WebGLHelper.prototype.handleWebGLContextLost = function () {\n        clear(this.bufferCache_);\n        this.currentProgram_ = null;\n    };\n    /**\n     * WebGL context was restored\n     * @private\n     */\n    WebGLHelper.prototype.handleWebGLContextRestored = function () { };\n    /**\n     * Will create or reuse a given webgl texture and apply the given size. If no image data\n     * specified, the texture will be empty, otherwise image data will be used and the `size`\n     * parameter will be ignored.\n     * Note: wrap parameters are set to clamp to edge, min filter is set to linear.\n     * @param {Array<number>} size Expected size of the texture\n     * @param {ImageData|HTMLImageElement|HTMLCanvasElement} [opt_data] Image data/object to bind to the texture\n     * @param {WebGLTexture} [opt_texture] Existing texture to reuse\n     * @return {WebGLTexture} The generated texture\n     * @api\n     */\n    WebGLHelper.prototype.createTexture = function (size, opt_data, opt_texture) {\n        var gl = this.getGL();\n        var texture = opt_texture || gl.createTexture();\n        // set params & size\n        var level = 0;\n        var internalFormat = gl.RGBA;\n        var border = 0;\n        var format = gl.RGBA;\n        var type = gl.UNSIGNED_BYTE;\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        if (opt_data) {\n            gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, format, type, opt_data);\n        }\n        else {\n            gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, size[0], size[1], border, format, type, null);\n        }\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        return texture;\n    };\n    return WebGLHelper;\n}(Disposable));\n/**\n * Compute a stride in bytes based on a list of attributes\n * @param {Array<AttributeDescription>} attributes Ordered list of attributes\n * @return {number} Stride, ie amount of values for each vertex in the vertex buffer\n * @api\n */\nexport function computeAttributesStride(attributes) {\n    var stride = 0;\n    for (var i = 0; i < attributes.length; i++) {\n        var attr = attributes[i];\n        stride += attr.size * getByteSizeFromType(attr.type);\n    }\n    return stride;\n}\n/**\n * Computes the size in byte of an attribute type.\n * @param {AttributeType} type Attribute type\n * @return {number} The size in bytes\n */\nfunction getByteSizeFromType(type) {\n    switch (type) {\n        case AttributeType.UNSIGNED_BYTE:\n            return Uint8Array.BYTES_PER_ELEMENT;\n        case AttributeType.UNSIGNED_SHORT:\n            return Uint16Array.BYTES_PER_ELEMENT;\n        case AttributeType.UNSIGNED_INT:\n            return Uint32Array.BYTES_PER_ELEMENT;\n        case AttributeType.FLOAT:\n        default:\n            return Float32Array.BYTES_PER_ELEMENT;\n    }\n}\nexport default WebGLHelper;\n//# sourceMappingURL=Helper.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/renderer/webgl/Layer\n */\nimport LayerRenderer from '../Layer.js';\nimport RenderEvent from '../../render/Event.js';\nimport RenderEventType from '../../render/EventType.js';\nimport WebGLHelper from '../../webgl/Helper.js';\n/**\n * @enum {string}\n */\nexport var WebGLWorkerMessageType = {\n    GENERATE_BUFFERS: 'GENERATE_BUFFERS',\n};\n/**\n * @typedef {Object} WebGLWorkerGenerateBuffersMessage\n * This message will trigger the generation of a vertex and an index buffer based on the given render instructions.\n * When the buffers are generated, the worked will send a message of the same type to the main thread, with\n * the generated buffers in it.\n * Note that any addition properties present in the message *will* be sent back to the main thread.\n * @property {WebGLWorkerMessageType} type Message type\n * @property {ArrayBuffer} renderInstructions Render instructions raw binary buffer.\n * @property {ArrayBuffer} [vertexBuffer] Vertices array raw binary buffer (sent by the worker).\n * @property {ArrayBuffer} [indexBuffer] Indices array raw binary buffer (sent by the worker).\n * @property {number} [customAttributesCount] Amount of custom attributes count in the render instructions.\n */\n/**\n * @typedef {Object} PostProcessesOptions\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas that will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * @property {Array<PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n/**\n * @classdesc\n * Base WebGL renderer class.\n * Holds all logic related to data manipulation & some common rendering logic\n * @template {import(\"../../layer/Layer.js\").default} LayerType\n */\nvar WebGLLayerRenderer = /** @class */ (function (_super) {\n    __extends(WebGLLayerRenderer, _super);\n    /**\n     * @param {LayerType} layer Layer.\n     * @param {Options} [opt_options] Options.\n     */\n    function WebGLLayerRenderer(layer, opt_options) {\n        var _this = _super.call(this, layer) || this;\n        var options = opt_options || {};\n        /**\n         * @type {WebGLHelper}\n         * @protected\n         */\n        _this.helper = new WebGLHelper({\n            postProcesses: options.postProcesses,\n            uniforms: options.uniforms,\n        });\n        if (options.className !== undefined) {\n            _this.helper.getCanvas().className = options.className;\n        }\n        return _this;\n    }\n    /**\n     * Clean up.\n     */\n    WebGLLayerRenderer.prototype.disposeInternal = function () {\n        this.helper.dispose();\n        _super.prototype.disposeInternal.call(this);\n    };\n    /**\n     * @param {import(\"../../render/EventType.js\").default} type Event type.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @private\n     */\n    WebGLLayerRenderer.prototype.dispatchRenderEvent_ = function (type, frameState) {\n        var layer = this.getLayer();\n        if (layer.hasListener(type)) {\n            // RenderEvent does not get a context or an inversePixelTransform, because WebGL allows much less direct editing than Canvas2d does.\n            var event_1 = new RenderEvent(type, null, frameState, null);\n            layer.dispatchEvent(event_1);\n        }\n    };\n    /**\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.preRender = function (frameState) {\n        this.dispatchRenderEvent_(RenderEventType.PRERENDER, frameState);\n    };\n    /**\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @protected\n     */\n    WebGLLayerRenderer.prototype.postRender = function (frameState) {\n        this.dispatchRenderEvent_(RenderEventType.POSTRENDER, frameState);\n    };\n    return WebGLLayerRenderer;\n}(LayerRenderer));\nvar tmpArray_ = [];\nvar bufferPositions_ = { vertexPosition: 0, indexPosition: 0 };\nfunction writePointVertex(buffer, pos, x, y, index) {\n    buffer[pos + 0] = x;\n    buffer[pos + 1] = y;\n    buffer[pos + 2] = index;\n}\n/**\n * An object holding positions both in an index and a vertex buffer.\n * @typedef {Object} BufferPositions\n * @property {number} vertexPosition Position in the vertex buffer\n * @property {number} indexPosition Position in the index buffer\n */\n/**\n * Pushes a quad (two triangles) based on a point geometry\n * @param {Float32Array} instructions Array of render instructions for points.\n * @param {number} elementIndex Index from which render instructions will be read.\n * @param {Float32Array} vertexBuffer Buffer in the form of a typed array.\n * @param {Uint32Array} indexBuffer Buffer in the form of a typed array.\n * @param {number} customAttributesCount Amount of custom attributes for each element.\n * @param {BufferPositions} [bufferPositions] Buffer write positions; if not specified, positions will be set at 0.\n * @return {BufferPositions} New buffer positions where to write next\n * @property {number} vertexPosition New position in the vertex buffer where future writes should start.\n * @property {number} indexPosition New position in the index buffer where future writes should start.\n * @private\n */\nexport function writePointFeatureToBuffers(instructions, elementIndex, vertexBuffer, indexBuffer, customAttributesCount, bufferPositions) {\n    // This is for x, y and index\n    var baseVertexAttrsCount = 3;\n    var baseInstructionsCount = 2;\n    var stride = baseVertexAttrsCount + customAttributesCount;\n    var x = instructions[elementIndex + 0];\n    var y = instructions[elementIndex + 1];\n    // read custom numerical attributes on the feature\n    var customAttrs = tmpArray_;\n    customAttrs.length = customAttributesCount;\n    for (var i = 0; i < customAttrs.length; i++) {\n        customAttrs[i] = instructions[elementIndex + baseInstructionsCount + i];\n    }\n    var vPos = bufferPositions ? bufferPositions.vertexPosition : 0;\n    var iPos = bufferPositions ? bufferPositions.indexPosition : 0;\n    var baseIndex = vPos / stride;\n    // push vertices for each of the four quad corners (first standard then custom attributes)\n    writePointVertex(vertexBuffer, vPos, x, y, 0);\n    customAttrs.length &&\n        vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n    vPos += stride;\n    writePointVertex(vertexBuffer, vPos, x, y, 1);\n    customAttrs.length &&\n        vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n    vPos += stride;\n    writePointVertex(vertexBuffer, vPos, x, y, 2);\n    customAttrs.length &&\n        vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n    vPos += stride;\n    writePointVertex(vertexBuffer, vPos, x, y, 3);\n    customAttrs.length &&\n        vertexBuffer.set(customAttrs, vPos + baseVertexAttrsCount);\n    vPos += stride;\n    indexBuffer[iPos++] = baseIndex;\n    indexBuffer[iPos++] = baseIndex + 1;\n    indexBuffer[iPos++] = baseIndex + 3;\n    indexBuffer[iPos++] = baseIndex + 1;\n    indexBuffer[iPos++] = baseIndex + 2;\n    indexBuffer[iPos++] = baseIndex + 3;\n    bufferPositions_.vertexPosition = vPos;\n    bufferPositions_.indexPosition = iPos;\n    return bufferPositions_;\n}\n/**\n * Returns a texture of 1x1 pixel, white\n * @private\n * @return {ImageData} Image data.\n */\nexport function getBlankImageData() {\n    var canvas = document.createElement('canvas');\n    var image = canvas.getContext('2d').createImageData(1, 1);\n    image.data[0] = 255;\n    image.data[1] = 255;\n    image.data[2] = 255;\n    image.data[3] = 255;\n    return image;\n}\n/**\n * Generates a color array based on a numerical id\n * Note: the range for each component is 0 to 1 with 256 steps\n * @param {number} id Id\n * @param {Array<number>} [opt_array] Reusable array\n * @return {Array<number>} Color array containing the encoded id\n */\nexport function colorEncodeId(id, opt_array) {\n    var array = opt_array || [];\n    var radix = 256;\n    var divide = radix - 1;\n    array[0] = Math.floor(id / radix / radix / radix) / divide;\n    array[1] = (Math.floor(id / radix / radix) % radix) / divide;\n    array[2] = (Math.floor(id / radix) % radix) / divide;\n    array[3] = (id % radix) / divide;\n    return array;\n}\n/**\n * Reads an id from a color-encoded array\n * Note: the expected range for each component is 0 to 1 with 256 steps.\n * @param {Array<number>} color Color array containing the encoded id\n * @return {number} Decoded id\n */\nexport function colorDecodeId(color) {\n    var id = 0;\n    var radix = 256;\n    var mult = radix - 1;\n    id += Math.round(color[0] * radix * radix * radix * mult);\n    id += Math.round(color[1] * radix * radix * mult);\n    id += Math.round(color[2] * radix * mult);\n    id += Math.round(color[3] * mult);\n    return id;\n}\nexport default WebGLLayerRenderer;\n//# sourceMappingURL=Layer.js.map","/**\n * A wrapper class to simplify rendering to a texture instead of the final canvas\n * @module ol/webgl/RenderTarget\n */\nimport { equals } from '../array.js';\n// for pixel color reading\nvar tmpArray4 = new Uint8Array(4);\n/**\n * @classdesc\n * This class is a wrapper around the association of both a `WebGLTexture` and a `WebGLFramebuffer` instances,\n * simplifying initialization and binding for rendering.\n * @api\n */\nvar WebGLRenderTarget = /** @class */ (function () {\n    /**\n     * @param {import(\"./Helper.js\").default} helper WebGL helper; mandatory.\n     * @param {Array<number>} [opt_size] Expected size of the render target texture; note: this can be changed later on.\n     */\n    function WebGLRenderTarget(helper, opt_size) {\n        /**\n         * @private\n         * @type {import(\"./Helper.js\").default}\n         */\n        this.helper_ = helper;\n        var gl = helper.getGL();\n        /**\n         * @private\n         * @type {WebGLTexture}\n         */\n        this.texture_ = gl.createTexture();\n        /**\n         * @private\n         * @type {WebGLFramebuffer}\n         */\n        this.framebuffer_ = gl.createFramebuffer();\n        /**\n         * @type {Array<number>}\n         * @private\n         */\n        this.size_ = opt_size || [1, 1];\n        /**\n         * @type {Uint8Array}\n         * @private\n         */\n        this.data_ = new Uint8Array(0);\n        /**\n         * @type {boolean}\n         * @private\n         */\n        this.dataCacheDirty_ = true;\n        this.updateSize_();\n    }\n    /**\n     * Changes the size of the render target texture. Note: will do nothing if the size\n     * is already the same.\n     * @param {Array<number>} size Expected size of the render target texture\n     * @api\n     */\n    WebGLRenderTarget.prototype.setSize = function (size) {\n        if (equals(size, this.size_)) {\n            return;\n        }\n        this.size_[0] = size[0];\n        this.size_[1] = size[1];\n        this.updateSize_();\n    };\n    /**\n     * Returns the size of the render target texture\n     * @return {Array<number>} Size of the render target texture\n     * @api\n     */\n    WebGLRenderTarget.prototype.getSize = function () {\n        return this.size_;\n    };\n    /**\n     * This will cause following calls to `#readAll` or `#readPixel` to download the content of the\n     * render target into memory, which is an expensive operation.\n     * This content will be kept in cache but should be cleared after each new render.\n     * @api\n     */\n    WebGLRenderTarget.prototype.clearCachedData = function () {\n        this.dataCacheDirty_ = true;\n    };\n    /**\n     * Returns the full content of the frame buffer as a series of r, g, b, a components\n     * in the 0-255 range (unsigned byte).\n     * @return {Uint8Array} Integer array of color values\n     * @api\n     */\n    WebGLRenderTarget.prototype.readAll = function () {\n        if (this.dataCacheDirty_) {\n            var size = this.size_;\n            var gl = this.helper_.getGL();\n            gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer_);\n            gl.readPixels(0, 0, size[0], size[1], gl.RGBA, gl.UNSIGNED_BYTE, this.data_);\n            this.dataCacheDirty_ = false;\n        }\n        return this.data_;\n    };\n    /**\n     * Reads one pixel of the frame buffer as an array of r, g, b, a components\n     * in the 0-255 range (unsigned byte).\n     * If x and/or y are outside of existing data, an array filled with 0 is returned.\n     * @param {number} x Pixel coordinate\n     * @param {number} y Pixel coordinate\n     * @return {Uint8Array} Integer array with one color value (4 components)\n     * @api\n     */\n    WebGLRenderTarget.prototype.readPixel = function (x, y) {\n        if (x < 0 || y < 0 || x > this.size_[0] || y >= this.size_[1]) {\n            tmpArray4[0] = 0;\n            tmpArray4[1] = 0;\n            tmpArray4[2] = 0;\n            tmpArray4[3] = 0;\n            return tmpArray4;\n        }\n        this.readAll();\n        var index = Math.floor(x) + (this.size_[1] - Math.floor(y) - 1) * this.size_[0];\n        tmpArray4[0] = this.data_[index * 4];\n        tmpArray4[1] = this.data_[index * 4 + 1];\n        tmpArray4[2] = this.data_[index * 4 + 2];\n        tmpArray4[3] = this.data_[index * 4 + 3];\n        return tmpArray4;\n    };\n    /**\n     * @return {WebGLTexture} Texture to render to\n     */\n    WebGLRenderTarget.prototype.getTexture = function () {\n        return this.texture_;\n    };\n    /**\n     * @return {WebGLFramebuffer} Frame buffer of the render target\n     */\n    WebGLRenderTarget.prototype.getFramebuffer = function () {\n        return this.framebuffer_;\n    };\n    /**\n     * @private\n     */\n    WebGLRenderTarget.prototype.updateSize_ = function () {\n        var size = this.size_;\n        var gl = this.helper_.getGL();\n        this.texture_ = this.helper_.createTexture(size, null, this.texture_);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer_);\n        gl.viewport(0, 0, size[0], size[1]);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture_, 0);\n        this.data_ = new Uint8Array(size[0] * size[1] * 4);\n    };\n    return WebGLRenderTarget;\n}());\nexport default WebGLRenderTarget;\n//# sourceMappingURL=RenderTarget.js.map","var source = \"var e=\\\"function\\\"==typeof Object.assign?Object.assign:function(e,n){if(null==e)throw new TypeError(\\\"Cannot convert undefined or null to object\\\");for(var t=Object(e),r=1,o=arguments.length;r<o;++r){var i=arguments[r];if(null!=i)for(var f in i)i.hasOwnProperty(f)&&(t[f]=i[f])}return t},n=\\\"GENERATE_BUFFERS\\\",t=[],r={vertexPosition:0,indexPosition:0};function o(e,n,t,r,o){e[n+0]=t,e[n+1]=r,e[n+2]=o}function i(e,n,i,f,s,u){var a=3+s,l=e[n+0],v=e[n+1],c=t;c.length=s;for(var g=0;g<c.length;g++)c[g]=e[n+2+g];var b=u?u.vertexPosition:0,h=u?u.indexPosition:0,d=b/a;return o(i,b,l,v,0),c.length&&i.set(c,b+3),o(i,b+=a,l,v,1),c.length&&i.set(c,b+3),o(i,b+=a,l,v,2),c.length&&i.set(c,b+3),o(i,b+=a,l,v,3),c.length&&i.set(c,b+3),b+=a,f[h++]=d,f[h++]=d+1,f[h++]=d+3,f[h++]=d+1,f[h++]=d+2,f[h++]=d+3,r.vertexPosition=b,r.indexPosition=h,r}var f=self;f.onmessage=function(t){var r=t.data;if(r.type===n){for(var o=r.customAttributesCount,s=2+o,u=new Float32Array(r.renderInstructions),a=u.length/s,l=4*a*(o+3),v=new Uint32Array(6*a),c=new Float32Array(l),g=null,b=0;b<u.length;b+=s)g=i(u,b,c,v,o,g);var h=e({vertexBuffer:c.buffer,indexBuffer:v.buffer,renderInstructions:u.buffer},r);f.postMessage(h,[c.buffer,v.buffer,u.buffer])}};\";\nvar blob = new Blob([source], { type: 'application/javascript' });\nvar url = URL.createObjectURL(blob);\nexport function create() {\n    return new Worker(url);\n}\n//# sourceMappingURL=webgl.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/renderer/webgl/PointsLayer\n */\nimport BaseVector from '../../layer/BaseVector.js';\nimport GeometryType from '../../geom/GeometryType.js';\nimport VectorEventType from '../../source/VectorEventType.js';\nimport ViewHint from '../../ViewHint.js';\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport WebGLLayerRenderer, { WebGLWorkerMessageType, colorDecodeId, colorEncodeId, } from './Layer.js';\nimport WebGLRenderTarget from '../../webgl/RenderTarget.js';\nimport { ARRAY_BUFFER, DYNAMIC_DRAW, ELEMENT_ARRAY_BUFFER } from '../../webgl.js';\nimport { AttributeType, DefaultUniform } from '../../webgl/Helper.js';\nimport { apply as applyTransform, create as createTransform, makeInverse as makeInverseTransform, multiply as multiplyTransform, } from '../../transform.js';\nimport { assert } from '../../asserts.js';\nimport { buffer, createEmpty, equals } from '../../extent.js';\nimport { create as createWebGLWorker } from '../../worker/webgl.js';\nimport { getUid } from '../../util.js';\nimport { listen, unlistenByKey } from '../../events.js';\n/**\n * @typedef {Object} CustomAttribute A description of a custom attribute to be passed on to the GPU, with a value different\n * for each feature.\n * @property {string} name Attribute name.\n * @property {function(import(\"../../Feature\").default, Object<string, *>):number} callback This callback computes the numerical value of the\n * attribute for a given feature (properties are available as 2nd arg for quicker access).\n */\n/**\n * @typedef {Object} FeatureCacheItem Object that holds a reference to a feature, its geometry and properties. Used to optimize\n * rebuildBuffers by accessing these objects quicker.\n * @property {import(\"../../Feature\").default} feature Feature\n * @property {Object<string, *>} properties Feature properties\n * @property {import(\"../../geom\").Geometry} geometry Feature geometry\n */\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {Array<CustomAttribute>} [attributes] These attributes will be read from the features in the source and then\n * passed to the GPU. The `name` property of each attribute will serve as its identifier:\n *  * In the vertex shader as an `attribute` by prefixing it with `a_`\n *  * In the fragment shader as a `varying` by prefixing it with `v_`\n * Please note that these can only be numerical values.\n * @property {string} vertexShader Vertex shader source, mandatory.\n * @property {string} fragmentShader Fragment shader source, mandatory.\n * @property {string} [hitVertexShader] Vertex shader source for hit detection rendering.\n * @property {string} [hitFragmentShader] Fragment shader source for hit detection rendering.\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions for the post process steps\n * Please note that `u_texture` is reserved for the main texture slot.\n * @property {Array<import(\"./Layer\").PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n/**\n * @classdesc\n * WebGL vector renderer optimized for points.\n * All features will be rendered as quads (two triangles forming a square). New data will be flushed to the GPU\n * every time the vector source changes.\n *\n * You need to provide vertex and fragment shaders for rendering. This can be done using\n * {@link module:ol/webgl/ShaderBuilder} utilities. These shaders shall expect a `a_position` attribute\n * containing the screen-space projected center of the quad, as well as a `a_index` attribute\n * whose value (0, 1, 2 or 3) indicates which quad vertex is currently getting processed (see structure below).\n *\n * To include variable attributes in the shaders, you need to declare them using the `attributes` property of\n * the options object like so:\n * ```js\n * new WebGLPointsLayerRenderer(layer, {\n *   attributes: [\n *     {\n *       name: 'size',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *     {\n *       name: 'weight',\n *       callback: function(feature) {\n *         // compute something with the feature\n *       }\n *     },\n *   ],\n *   vertexShader:\n *     // shader using attribute a_weight and a_size\n *   fragmentShader:\n *     // shader using varying v_weight and v_size\n * ```\n *\n * To enable hit detection, you must as well provide dedicated shaders using the `hitVertexShader`\n * and `hitFragmentShader` properties. These shall expect the `a_hitColor` attribute to contain\n * the final color that will have to be output for hit detection to work.\n *\n * The following uniform is used for the main texture: `u_texture`.\n *\n * Please note that the main shader output should have premultiplied alpha, otherwise visual anomalies may occur.\n *\n * Points are rendered as quads with the following structure:\n *\n * ```\n *   (u0, v1)      (u1, v1)\n *  [3]----------[2]\n *   |`           |\n *   |  `         |\n *   |    `       |\n *   |      `     |\n *   |        `   |\n *   |          ` |\n *  [0]----------[1]\n *   (u0, v0)      (u1, v0)\n *  ```\n *\n * This uses {@link module:ol/webgl/Helper~WebGLHelper} internally.\n *\n * @api\n */\nvar WebGLPointsLayerRenderer = /** @class */ (function (_super) {\n    __extends(WebGLPointsLayerRenderer, _super);\n    /**\n     * @param {import(\"../../layer/Layer.js\").default} layer Layer.\n     * @param {Options} options Options.\n     */\n    function WebGLPointsLayerRenderer(layer, options) {\n        var _this = this;\n        var uniforms = options.uniforms || {};\n        var projectionMatrixTransform = createTransform();\n        uniforms[DefaultUniform.PROJECTION_MATRIX] = projectionMatrixTransform;\n        _this = _super.call(this, layer, {\n            className: options.className,\n            uniforms: uniforms,\n            postProcesses: options.postProcesses,\n        }) || this;\n        _this.sourceRevision_ = -1;\n        _this.verticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n        _this.hitVerticesBuffer_ = new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW);\n        _this.indicesBuffer_ = new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, DYNAMIC_DRAW);\n        _this.program_ = _this.helper.getProgram(options.fragmentShader, options.vertexShader);\n        /**\n         * @type {boolean}\n         * @private\n         */\n        _this.hitDetectionEnabled_ =\n            options.hitFragmentShader && options.hitVertexShader ? true : false;\n        _this.hitProgram_ =\n            _this.hitDetectionEnabled_ &&\n                _this.helper.getProgram(options.hitFragmentShader, options.hitVertexShader);\n        var customAttributes = options.attributes\n            ? options.attributes.map(function (attribute) {\n                return {\n                    name: 'a_' + attribute.name,\n                    size: 1,\n                    type: AttributeType.FLOAT,\n                };\n            })\n            : [];\n        /**\n         * A list of attributes used by the renderer. By default only the position and\n         * index of the vertex (0 to 3) are required.\n         * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n         */\n        _this.attributes = [\n            {\n                name: 'a_position',\n                size: 2,\n                type: AttributeType.FLOAT,\n            },\n            {\n                name: 'a_index',\n                size: 1,\n                type: AttributeType.FLOAT,\n            },\n        ].concat(customAttributes);\n        /**\n         * A list of attributes used for hit detection.\n         * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n         */\n        _this.hitDetectionAttributes = [\n            {\n                name: 'a_position',\n                size: 2,\n                type: AttributeType.FLOAT,\n            },\n            {\n                name: 'a_index',\n                size: 1,\n                type: AttributeType.FLOAT,\n            },\n            {\n                name: 'a_hitColor',\n                size: 4,\n                type: AttributeType.FLOAT,\n            },\n            {\n                name: 'a_featureUid',\n                size: 1,\n                type: AttributeType.FLOAT,\n            },\n        ].concat(customAttributes);\n        _this.customAttributes = options.attributes ? options.attributes : [];\n        _this.previousExtent_ = createEmpty();\n        /**\n         * This transform is updated on every frame and is the composition of:\n         * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)\n         * - current world->screen transform\n         * @type {import(\"../../transform.js\").Transform}\n         * @private\n         */\n        _this.currentTransform_ = projectionMatrixTransform;\n        /**\n         * This transform is updated when buffers are rebuilt and converts world space coordinates to screen space\n         * @type {import(\"../../transform.js\").Transform}\n         * @private\n         */\n        _this.renderTransform_ = createTransform();\n        /**\n         * @type {import(\"../../transform.js\").Transform}\n         * @private\n         */\n        _this.invertRenderTransform_ = createTransform();\n        /**\n         * @type {Float32Array}\n         * @private\n         */\n        _this.renderInstructions_ = new Float32Array(0);\n        /**\n         * These instructions are used for hit detection\n         * @type {Float32Array}\n         * @private\n         */\n        _this.hitRenderInstructions_ = new Float32Array(0);\n        /**\n         * @type {WebGLRenderTarget}\n         * @private\n         */\n        _this.hitRenderTarget_ =\n            _this.hitDetectionEnabled_ && new WebGLRenderTarget(_this.helper);\n        _this.worker_ = createWebGLWorker();\n        _this.worker_.addEventListener('message', \n        /**\n         * @param {*} event Event.\n         * @this {WebGLPointsLayerRenderer}\n         */\n        function (event) {\n            var received = event.data;\n            if (received.type === WebGLWorkerMessageType.GENERATE_BUFFERS) {\n                var projectionTransform = received.projectionTransform;\n                if (received.hitDetection) {\n                    this.hitVerticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n                    this.helper.flushBufferData(this.hitVerticesBuffer_);\n                }\n                else {\n                    this.verticesBuffer_.fromArrayBuffer(received.vertexBuffer);\n                    this.helper.flushBufferData(this.verticesBuffer_);\n                }\n                this.indicesBuffer_.fromArrayBuffer(received.indexBuffer);\n                this.helper.flushBufferData(this.indicesBuffer_);\n                this.renderTransform_ = projectionTransform;\n                makeInverseTransform(this.invertRenderTransform_, this.renderTransform_);\n                if (received.hitDetection) {\n                    this.hitRenderInstructions_ = new Float32Array(event.data.renderInstructions);\n                }\n                else {\n                    this.renderInstructions_ = new Float32Array(event.data.renderInstructions);\n                }\n                this.getLayer().changed();\n            }\n        }.bind(_this));\n        /**\n         * This object will be updated when the source changes. Key is uid.\n         * @type {Object<string, FeatureCacheItem>}\n         * @private\n         */\n        _this.featureCache_ = {};\n        /**\n         * Amount of features in the cache.\n         * @type {number}\n         * @private\n         */\n        _this.featureCount_ = 0;\n        var source = _this.getLayer().getSource();\n        _this.sourceListenKeys_ = [\n            listen(source, VectorEventType.ADDFEATURE, _this.handleSourceFeatureAdded_, _this),\n            listen(source, VectorEventType.CHANGEFEATURE, _this.handleSourceFeatureChanged_, _this),\n            listen(source, VectorEventType.REMOVEFEATURE, _this.handleSourceFeatureDelete_, _this),\n            listen(source, VectorEventType.CLEAR, _this.handleSourceFeatureClear_, _this),\n        ];\n        source.forEachFeature(function (feature) {\n            this.featureCache_[getUid(feature)] = {\n                feature: feature,\n                properties: feature.getProperties(),\n                geometry: feature.getGeometry(),\n            };\n            this.featureCount_++;\n        }.bind(_this));\n        return _this;\n    }\n    /**\n     * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.handleSourceFeatureAdded_ = function (event) {\n        var feature = event.feature;\n        this.featureCache_[getUid(feature)] = {\n            feature: feature,\n            properties: feature.getProperties(),\n            geometry: feature.getGeometry(),\n        };\n        this.featureCount_++;\n    };\n    /**\n     * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.handleSourceFeatureChanged_ = function (event) {\n        var feature = event.feature;\n        this.featureCache_[getUid(feature)] = {\n            feature: feature,\n            properties: feature.getProperties(),\n            geometry: feature.getGeometry(),\n        };\n    };\n    /**\n     * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.handleSourceFeatureDelete_ = function (event) {\n        var feature = event.feature;\n        delete this.featureCache_[getUid(feature)];\n        this.featureCount_--;\n    };\n    /**\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.handleSourceFeatureClear_ = function () {\n        this.featureCache_ = {};\n        this.featureCount_ = 0;\n    };\n    /**\n     * Render the layer.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {HTMLElement} The rendered element.\n     */\n    WebGLPointsLayerRenderer.prototype.renderFrame = function (frameState) {\n        this.preRender(frameState);\n        var renderCount = this.indicesBuffer_.getSize();\n        this.helper.drawElements(0, renderCount);\n        this.helper.finalizeDraw(frameState);\n        var canvas = this.helper.getCanvas();\n        var layerState = frameState.layerStatesArray[frameState.layerIndex];\n        var opacity = layerState.opacity;\n        if (opacity !== parseFloat(canvas.style.opacity)) {\n            canvas.style.opacity = String(opacity);\n        }\n        if (this.hitDetectionEnabled_) {\n            this.renderHitDetection(frameState);\n            this.hitRenderTarget_.clearCachedData();\n        }\n        this.postRender(frameState);\n        return canvas;\n    };\n    /**\n     * Determine whether render should be called.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @return {boolean} Layer is ready to be rendered.\n     */\n    WebGLPointsLayerRenderer.prototype.prepareFrame = function (frameState) {\n        var layer = this.getLayer();\n        var vectorSource = layer.getSource();\n        var viewState = frameState.viewState;\n        var viewNotMoving = !frameState.viewHints[ViewHint.ANIMATING] &&\n            !frameState.viewHints[ViewHint.INTERACTING];\n        var extentChanged = !equals(this.previousExtent_, frameState.extent);\n        var sourceChanged = this.sourceRevision_ < vectorSource.getRevision();\n        if (sourceChanged) {\n            this.sourceRevision_ = vectorSource.getRevision();\n        }\n        if (viewNotMoving && (extentChanged || sourceChanged)) {\n            var projection = viewState.projection;\n            var resolution = viewState.resolution;\n            var renderBuffer = layer instanceof BaseVector ? layer.getRenderBuffer() : 0;\n            var extent = buffer(frameState.extent, renderBuffer * resolution);\n            vectorSource.loadFeatures(extent, resolution, projection);\n            this.rebuildBuffers_(frameState);\n            this.previousExtent_ = frameState.extent.slice();\n        }\n        // apply the current projection transform with the invert of the one used to fill buffers\n        this.helper.makeProjectionTransform(frameState, this.currentTransform_);\n        multiplyTransform(this.currentTransform_, this.invertRenderTransform_);\n        this.helper.useProgram(this.program_);\n        this.helper.prepareDraw(frameState);\n        // write new data\n        this.helper.bindBuffer(this.verticesBuffer_);\n        this.helper.bindBuffer(this.indicesBuffer_);\n        this.helper.enableAttributes(this.attributes);\n        return true;\n    };\n    /**\n     * Rebuild internal webgl buffers based on current view extent; costly, should not be called too much\n     * @param {import(\"../../PluggableMap\").FrameState} frameState Frame state.\n     * @private\n     */\n    WebGLPointsLayerRenderer.prototype.rebuildBuffers_ = function (frameState) {\n        // saves the projection transform for the current frame state\n        var projectionTransform = createTransform();\n        this.helper.makeProjectionTransform(frameState, projectionTransform);\n        // here we anticipate the amount of render instructions that we well generate\n        // this can be done since we know that for normal render we only have x, y as base instructions,\n        // and x, y, r, g, b, a and featureUid for hit render instructions\n        // and we also know the amount of custom attributes to append to these\n        var totalInstructionsCount = (2 + this.customAttributes.length) * this.featureCount_;\n        if (!this.renderInstructions_ ||\n            this.renderInstructions_.length !== totalInstructionsCount) {\n            this.renderInstructions_ = new Float32Array(totalInstructionsCount);\n        }\n        if (this.hitDetectionEnabled_) {\n            var totalHitInstructionsCount = (7 + this.customAttributes.length) * this.featureCount_;\n            if (!this.hitRenderInstructions_ ||\n                this.hitRenderInstructions_.length !== totalHitInstructionsCount) {\n                this.hitRenderInstructions_ = new Float32Array(totalHitInstructionsCount);\n            }\n        }\n        // loop on features to fill the buffer\n        var featureCache, geometry;\n        var tmpCoords = [];\n        var tmpColor = [];\n        var renderIndex = 0;\n        var hitIndex = 0;\n        var hitColor;\n        for (var featureUid in this.featureCache_) {\n            featureCache = this.featureCache_[featureUid];\n            geometry = /** @type {import(\"../../geom\").Point} */ (featureCache.geometry);\n            if (!geometry || geometry.getType() !== GeometryType.POINT) {\n                continue;\n            }\n            tmpCoords[0] = geometry.getFlatCoordinates()[0];\n            tmpCoords[1] = geometry.getFlatCoordinates()[1];\n            applyTransform(projectionTransform, tmpCoords);\n            hitColor = colorEncodeId(hitIndex + 6, tmpColor);\n            this.renderInstructions_[renderIndex++] = tmpCoords[0];\n            this.renderInstructions_[renderIndex++] = tmpCoords[1];\n            // for hit detection, the feature uid is saved in the opacity value\n            // and the index of the opacity value is encoded in the color values\n            if (this.hitDetectionEnabled_) {\n                this.hitRenderInstructions_[hitIndex++] = tmpCoords[0];\n                this.hitRenderInstructions_[hitIndex++] = tmpCoords[1];\n                this.hitRenderInstructions_[hitIndex++] = hitColor[0];\n                this.hitRenderInstructions_[hitIndex++] = hitColor[1];\n                this.hitRenderInstructions_[hitIndex++] = hitColor[2];\n                this.hitRenderInstructions_[hitIndex++] = hitColor[3];\n                this.hitRenderInstructions_[hitIndex++] = Number(featureUid);\n            }\n            // pushing custom attributes\n            var value = void 0;\n            for (var j = 0; j < this.customAttributes.length; j++) {\n                value = this.customAttributes[j].callback(featureCache.feature, featureCache.properties);\n                this.renderInstructions_[renderIndex++] = value;\n                if (this.hitDetectionEnabled_) {\n                    this.hitRenderInstructions_[hitIndex++] = value;\n                }\n            }\n        }\n        /** @type {import('./Layer').WebGLWorkerGenerateBuffersMessage} */\n        var message = {\n            type: WebGLWorkerMessageType.GENERATE_BUFFERS,\n            renderInstructions: this.renderInstructions_.buffer,\n            customAttributesCount: this.customAttributes.length,\n        };\n        // additional properties will be sent back as-is by the worker\n        message['projectionTransform'] = projectionTransform;\n        this.worker_.postMessage(message, [this.renderInstructions_.buffer]);\n        this.renderInstructions_ = null;\n        /** @type {import('./Layer').WebGLWorkerGenerateBuffersMessage} */\n        if (this.hitDetectionEnabled_) {\n            var hitMessage = {\n                type: WebGLWorkerMessageType.GENERATE_BUFFERS,\n                renderInstructions: this.hitRenderInstructions_.buffer,\n                customAttributesCount: 5 + this.customAttributes.length,\n            };\n            hitMessage['projectionTransform'] = projectionTransform;\n            hitMessage['hitDetection'] = true;\n            this.worker_.postMessage(hitMessage, [\n                this.hitRenderInstructions_.buffer,\n            ]);\n            this.hitRenderInstructions_ = null;\n        }\n    };\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState Frame state.\n     * @param {number} hitTolerance Hit tolerance in pixels.\n     * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n     * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n     * @return {T|undefined} Callback result.\n     * @template T\n     */\n    WebGLPointsLayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, matches) {\n        assert(this.hitDetectionEnabled_, 66);\n        if (!this.hitRenderInstructions_) {\n            return undefined;\n        }\n        var pixel = applyTransform(frameState.coordinateToPixelTransform, coordinate.slice());\n        var data = this.hitRenderTarget_.readPixel(pixel[0] / 2, pixel[1] / 2);\n        var color = [data[0] / 255, data[1] / 255, data[2] / 255, data[3] / 255];\n        var index = colorDecodeId(color);\n        var opacity = this.hitRenderInstructions_[index];\n        var uid = Math.floor(opacity).toString();\n        var source = this.getLayer().getSource();\n        var feature = source.getFeatureByUid(uid);\n        if (feature) {\n            return callback(feature, this.getLayer(), null);\n        }\n        return undefined;\n    };\n    /**\n     * Render the hit detection data to the corresponding render target\n     * @param {import(\"../../PluggableMap.js\").FrameState} frameState current frame state\n     */\n    WebGLPointsLayerRenderer.prototype.renderHitDetection = function (frameState) {\n        // skip render entirely if vertex buffers not ready/generated yet\n        if (!this.hitVerticesBuffer_.getSize()) {\n            return;\n        }\n        this.hitRenderTarget_.setSize([\n            Math.floor(frameState.size[0] / 2),\n            Math.floor(frameState.size[1] / 2),\n        ]);\n        this.helper.useProgram(this.hitProgram_);\n        this.helper.prepareDrawToRenderTarget(frameState, this.hitRenderTarget_, true);\n        this.helper.bindBuffer(this.hitVerticesBuffer_);\n        this.helper.bindBuffer(this.indicesBuffer_);\n        this.helper.enableAttributes(this.hitDetectionAttributes);\n        var renderCount = this.indicesBuffer_.getSize();\n        this.helper.drawElements(0, renderCount);\n    };\n    /**\n     * Clean up.\n     */\n    WebGLPointsLayerRenderer.prototype.disposeInternal = function () {\n        this.worker_.terminate();\n        this.layer_ = null;\n        this.sourceListenKeys_.forEach(function (key) {\n            unlistenByKey(key);\n        });\n        this.sourceListenKeys_ = null;\n        _super.prototype.disposeInternal.call(this);\n    };\n    return WebGLPointsLayerRenderer;\n}(WebGLLayerRenderer));\nexport default WebGLPointsLayerRenderer;\n//# sourceMappingURL=PointsLayer.js.map","var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n/**\n * @module ol/layer/Heatmap\n */\nimport VectorLayer from './Vector.js';\nimport WebGLPointsLayerRenderer from '../renderer/webgl/PointsLayer.js';\nimport { assign } from '../obj.js';\nimport { clamp } from '../math.js';\nimport { createCanvasContext2D } from '../dom.js';\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.\n * @property {number} [opacity=1] Opacity (0, 1).\n * @property {boolean} [visible=true] Visibility.\n * @property {import(\"../extent.js\").Extent} [extent] The bounding extent for layer rendering.  The layer will not be\n * rendered outside of this extent.\n * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers\n * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed\n * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`\n * method was used.\n * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be\n * visible.\n * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will\n * be visible.\n * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be\n * visible.\n * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will\n * be visible.\n * @property {Array<string>} [gradient=['#00f', '#0ff', '#0f0', '#ff0', '#f00']] The color gradient\n * of the heatmap, specified as an array of CSS color strings.\n * @property {number} [radius=8] Radius size in pixels.\n * @property {number} [blur=15] Blur size in pixels.\n * @property {string|function(import(\"../Feature.js\").default):number} [weight='weight'] The feature\n * attribute to use for the weight or a function that returns a weight from a feature. Weight values\n * should range from 0 to 1 (and values outside will be clamped to that range).\n * @property {import(\"../source/Vector.js\").default} [source] Source.\n * @property {Object<string, *>} [properties] Arbitrary observable properties. Can be accessed with `#get()` and `#set()`.\n */\n/**\n * @enum {string}\n * @private\n */\nvar Property = {\n    BLUR: 'blur',\n    GRADIENT: 'gradient',\n    RADIUS: 'radius',\n};\n/**\n * @const\n * @type {Array<string>}\n */\nvar DEFAULT_GRADIENT = ['#00f', '#0ff', '#0f0', '#ff0', '#f00'];\n/**\n * @classdesc\n * Layer for rendering vector data as a heatmap.\n * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}\n * property on the layer object; for example, setting `title: 'My Title'` in the\n * options means that `title` is observable, and has get/set accessors.\n *\n * @fires import(\"../render/Event.js\").RenderEvent\n * @extends {VectorLayer<import(\"../source/Vector.js\").default>}\n * @api\n */\nvar Heatmap = /** @class */ (function (_super) {\n    __extends(Heatmap, _super);\n    /**\n     * @param {Options} [opt_options] Options.\n     */\n    function Heatmap(opt_options) {\n        var _this = this;\n        var options = opt_options ? opt_options : {};\n        var baseOptions = assign({}, options);\n        delete baseOptions.gradient;\n        delete baseOptions.radius;\n        delete baseOptions.blur;\n        delete baseOptions.weight;\n        _this = _super.call(this, baseOptions) || this;\n        /**\n         * @private\n         * @type {HTMLCanvasElement}\n         */\n        _this.gradient_ = null;\n        _this.addChangeListener(Property.GRADIENT, _this.handleGradientChanged_);\n        _this.setGradient(options.gradient ? options.gradient : DEFAULT_GRADIENT);\n        _this.setBlur(options.blur !== undefined ? options.blur : 15);\n        _this.setRadius(options.radius !== undefined ? options.radius : 8);\n        var weight = options.weight ? options.weight : 'weight';\n        if (typeof weight === 'string') {\n            _this.weightFunction_ = function (feature) {\n                return feature.get(weight);\n            };\n        }\n        else {\n            _this.weightFunction_ = weight;\n        }\n        // For performance reasons, don't sort the features before rendering.\n        // The render order is not relevant for a heatmap representation.\n        _this.setRenderOrder(null);\n        return _this;\n    }\n    /**\n     * Return the blur size in pixels.\n     * @return {number} Blur size in pixels.\n     * @api\n     * @observable\n     */\n    Heatmap.prototype.getBlur = function () {\n        return /** @type {number} */ (this.get(Property.BLUR));\n    };\n    /**\n     * Return the gradient colors as array of strings.\n     * @return {Array<string>} Colors.\n     * @api\n     * @observable\n     */\n    Heatmap.prototype.getGradient = function () {\n        return /** @type {Array<string>} */ (this.get(Property.GRADIENT));\n    };\n    /**\n     * Return the size of the radius in pixels.\n     * @return {number} Radius size in pixel.\n     * @api\n     * @observable\n     */\n    Heatmap.prototype.getRadius = function () {\n        return /** @type {number} */ (this.get(Property.RADIUS));\n    };\n    /**\n     * @private\n     */\n    Heatmap.prototype.handleGradientChanged_ = function () {\n        this.gradient_ = createGradient(this.getGradient());\n    };\n    /**\n     * Set the blur size in pixels.\n     * @param {number} blur Blur size in pixels.\n     * @api\n     * @observable\n     */\n    Heatmap.prototype.setBlur = function (blur) {\n        this.set(Property.BLUR, blur);\n    };\n    /**\n     * Set the gradient colors as array of strings.\n     * @param {Array<string>} colors Gradient.\n     * @api\n     * @observable\n     */\n    Heatmap.prototype.setGradient = function (colors) {\n        this.set(Property.GRADIENT, colors);\n    };\n    /**\n     * Set the size of the radius in pixels.\n     * @param {number} radius Radius size in pixel.\n     * @api\n     * @observable\n     */\n    Heatmap.prototype.setRadius = function (radius) {\n        this.set(Property.RADIUS, radius);\n    };\n    /**\n     * Create a renderer for this layer.\n     * @return {WebGLPointsLayerRenderer} A layer renderer.\n     */\n    Heatmap.prototype.createRenderer = function () {\n        return new WebGLPointsLayerRenderer(this, {\n            className: this.getClassName(),\n            attributes: [\n                {\n                    name: 'weight',\n                    callback: function (feature) {\n                        var weight = this.weightFunction_(feature);\n                        return weight !== undefined ? clamp(weight, 0, 1) : 1;\n                    }.bind(this),\n                },\n            ],\n            vertexShader: \"\\n        precision mediump float;\\n        uniform mat4 u_projectionMatrix;\\n        uniform mat4 u_offsetScaleMatrix;\\n        uniform float u_size;\\n        attribute vec2 a_position;\\n        attribute float a_index;\\n        attribute float a_weight;\\n\\n        varying vec2 v_texCoord;\\n        varying float v_weight;\\n\\n        void main(void) {\\n          mat4 offsetMatrix = u_offsetScaleMatrix;\\n          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;\\n          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;\\n          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\\n          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\\n          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\\n          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;\\n          v_texCoord = vec2(u, v);\\n          v_weight = a_weight;\\n        }\",\n            fragmentShader: \"\\n        precision mediump float;\\n        uniform float u_blurSlope;\\n\\n        varying vec2 v_texCoord;\\n        varying float v_weight;\\n\\n        void main(void) {\\n          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);\\n          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;\\n          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;\\n          float alpha = smoothstep(0.0, 1.0, value) * v_weight;\\n          gl_FragColor = vec4(alpha, alpha, alpha, alpha);\\n        }\",\n            hitVertexShader: \"\\n        precision mediump float;\\n        uniform mat4 u_projectionMatrix;\\n        uniform mat4 u_offsetScaleMatrix;\\n        uniform float u_size;\\n        attribute vec2 a_position;\\n        attribute float a_index;\\n        attribute float a_weight;\\n        attribute vec4 a_hitColor;\\n\\n        varying vec2 v_texCoord;\\n        varying float v_weight;\\n        varying vec4 v_hitColor;\\n\\n        void main(void) {\\n          mat4 offsetMatrix = u_offsetScaleMatrix;\\n          float offsetX = a_index == 0.0 || a_index == 3.0 ? -u_size / 2.0 : u_size / 2.0;\\n          float offsetY = a_index == 0.0 || a_index == 1.0 ? -u_size / 2.0 : u_size / 2.0;\\n          vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\\n          gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\\n          float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\\n          float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;\\n          v_texCoord = vec2(u, v);\\n          v_hitColor = a_hitColor;\\n          v_weight = a_weight;\\n        }\",\n            hitFragmentShader: \"\\n        precision mediump float;\\n        uniform float u_blurSlope;\\n\\n        varying vec2 v_texCoord;\\n        varying float v_weight;\\n        varying vec4 v_hitColor;\\n\\n        void main(void) {\\n          vec2 texCoord = v_texCoord * 2.0 - vec2(1.0, 1.0);\\n          float sqRadius = texCoord.x * texCoord.x + texCoord.y * texCoord.y;\\n          float value = (1.0 - sqrt(sqRadius)) * u_blurSlope;\\n          float alpha = smoothstep(0.0, 1.0, value) * v_weight;\\n          if (alpha < 0.05) {\\n            discard;\\n          }\\n\\n          gl_FragColor = v_hitColor;\\n        }\",\n            uniforms: {\n                u_size: function () {\n                    return (this.get(Property.RADIUS) + this.get(Property.BLUR)) * 2;\n                }.bind(this),\n                u_blurSlope: function () {\n                    return (this.get(Property.RADIUS) / Math.max(1, this.get(Property.BLUR)));\n                }.bind(this),\n            },\n            postProcesses: [\n                {\n                    fragmentShader: \"\\n            precision mediump float;\\n\\n            uniform sampler2D u_image;\\n            uniform sampler2D u_gradientTexture;\\n\\n            varying vec2 v_texCoord;\\n\\n            void main() {\\n              vec4 color = texture2D(u_image, v_texCoord);\\n              gl_FragColor.a = color.a;\\n              gl_FragColor.rgb = texture2D(u_gradientTexture, vec2(0.5, color.a)).rgb;\\n              gl_FragColor.rgb *= gl_FragColor.a;\\n            }\",\n                    uniforms: {\n                        u_gradientTexture: function () {\n                            return this.gradient_;\n                        }.bind(this),\n                    },\n                },\n            ],\n        });\n    };\n    Heatmap.prototype.renderDeclutter = function () { };\n    return Heatmap;\n}(VectorLayer));\n/**\n * @param {Array<string>} colors A list of colored.\n * @return {HTMLCanvasElement} canvas with gradient texture.\n */\nfunction createGradient(colors) {\n    var width = 1;\n    var height = 256;\n    var context = createCanvasContext2D(width, height);\n    var gradient = context.createLinearGradient(0, 0, width, height);\n    var step = 1 / (colors.length - 1);\n    for (var i = 0, ii = colors.length; i < ii; ++i) {\n        gradient.addColorStop(i * step, colors[i]);\n    }\n    context.fillStyle = gradient;\n    context.fillRect(0, 0, width, height);\n    return context.canvas;\n}\nexport default Heatmap;\n//# sourceMappingURL=Heatmap.js.map","/**\n * @module ol/source/Stamen\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport XYZ from './XYZ.js';\nimport { ATTRIBUTION as OSM_ATTRIBUTION } from './OSM.js';\n/**\n * @const\n * @type {Array<string>}\n */\nvar ATTRIBUTIONS = [\n    'Map tiles by <a href=\"https://stamen.com/\" target=\"_blank\">Stamen Design</a>, ' +\n        'under <a href=\"https://creativecommons.org/licenses/by/3.0/\" target=\"_blank\">CC BY' +\n        ' 3.0</a>.',\n    OSM_ATTRIBUTION,\n];\n/**\n * @type {Object<string, {extension: string, opaque: boolean}>}\n */\nvar LayerConfig = {\n    'terrain': {\n        extension: 'jpg',\n        opaque: true,\n    },\n    'terrain-background': {\n        extension: 'jpg',\n        opaque: true,\n    },\n    'terrain-labels': {\n        extension: 'png',\n        opaque: false,\n    },\n    'terrain-lines': {\n        extension: 'png',\n        opaque: false,\n    },\n    'toner-background': {\n        extension: 'png',\n        opaque: true,\n    },\n    'toner': {\n        extension: 'png',\n        opaque: true,\n    },\n    'toner-hybrid': {\n        extension: 'png',\n        opaque: false,\n    },\n    'toner-labels': {\n        extension: 'png',\n        opaque: false,\n    },\n    'toner-lines': {\n        extension: 'png',\n        opaque: false,\n    },\n    'toner-lite': {\n        extension: 'png',\n        opaque: true,\n    },\n    'watercolor': {\n        extension: 'jpg',\n        opaque: true,\n    },\n};\n/**\n * @type {Object<string, {minZoom: number, maxZoom: number}>}\n */\nvar ProviderConfig = {\n    'terrain': {\n        minZoom: 0,\n        maxZoom: 18,\n    },\n    'toner': {\n        minZoom: 0,\n        maxZoom: 20,\n    },\n    'watercolor': {\n        minZoom: 0,\n        maxZoom: 18,\n    },\n};\n/**\n * @typedef {Object} Options\n * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.\n * @property {boolean} [imageSmoothing=true] Enable image smoothing.\n * @property {string} layer Layer name.\n * @property {number} [minZoom] Minimum zoom.\n * @property {number} [maxZoom] Maximum zoom.\n * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).\n * Higher values can increase reprojection performance, but decrease precision.\n * @property {import(\"../Tile.js\").LoadFunction} [tileLoadFunction]\n * Optional function to load a tile given a URL. The default is\n * ```js\n * function(imageTile, src) {\n *   imageTile.getImage().src = src;\n * };\n * ```\n * @property {number} [transition=250] Duration of the opacity transition for rendering.\n * To disable the opacity transition, pass `transition: 0`.\n * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.\n * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.\n * @property {number|import(\"../array.js\").NearestDirectionFunction} [zDirection=0]\n * Choose whether to use tiles with a higher or lower zoom level when between integer\n * zoom levels. See {@link module:ol/tilegrid/TileGrid~TileGrid#getZForResolution}.\n */\n/**\n * @classdesc\n * Layer source for the Stamen tile server.\n * @api\n */\nvar Stamen = /** @class */ (function (_super) {\n    __extends(Stamen, _super);\n    /**\n     * @param {Options} options Stamen options.\n     */\n    function Stamen(options) {\n        var _this = this;\n        var i = options.layer.indexOf('-');\n        var provider = i == -1 ? options.layer : options.layer.slice(0, i);\n        var providerConfig = ProviderConfig[provider];\n        var layerConfig = LayerConfig[options.layer];\n        var url = options.url !== undefined\n            ? options.url\n            : 'https://stamen-tiles-{a-d}.a.ssl.fastly.net/' +\n                options.layer +\n                '/{z}/{x}/{y}.' +\n                layerConfig.extension;\n        _this = _super.call(this, {\n            attributions: ATTRIBUTIONS,\n            cacheSize: options.cacheSize,\n            crossOrigin: 'anonymous',\n            imageSmoothing: options.imageSmoothing,\n            maxZoom: options.maxZoom != undefined ? options.maxZoom : providerConfig.maxZoom,\n            minZoom: options.minZoom != undefined ? options.minZoom : providerConfig.minZoom,\n            opaque: layerConfig.opaque,\n            reprojectionErrorThreshold: options.reprojectionErrorThreshold,\n            tileLoadFunction: options.tileLoadFunction,\n            transition: options.transition,\n            url: url,\n            wrapX: options.wrapX,\n            zDirection: options.zDirection,\n        }) || this;\n        return _this;\n    }\n    return Stamen;\n}(XYZ));\nexport default Stamen;\n//# sourceMappingURL=Stamen.js.map","<template>\r\n  <div class=\"vm\">\r\n    <h2 class=\"h-title\">热力图 Heatmap</h2>\r\n\r\n    <label>半径大小</label>\r\n    <input id=\"radius\" type=\"range\" min=\"1\" max=\"50\" step=\"1\" v-model=\"radius\" @change=\"changeRadius\" />\r\n    \r\n    <label>模糊半径</label>\r\n    <input id=\"blur\" type=\"range\" min=\"1\" max=\"50\" step=\"1\" v-model=\"blur\" @change=\"changeBlur\" />\r\n\r\n    <button @click=\"getHeatName\">输出涂层名</button>\r\n\r\n    <div id=\"map\" class=\"map-x\" ref=\"map\"></div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport 'ol/ol.css'\r\nimport { Map, View } from 'ol'\r\nimport { Heatmap, Tile } from 'ol/layer'\r\nimport { Vector as SourceVector, Stamen } from 'ol/source' // Stamen是底图\r\nimport HeatData from '@/assets/data/heatData.json' // 热力图数据\r\nimport GeoJSON from 'ol/format/GeoJSON' // 解析geojson格式\r\n\r\nexport default {\r\n  data() {\r\n    return {\r\n      map: null,\r\n      radius: 5,\r\n      blur: 15,\r\n      vector: new Heatmap({ // 热力图\r\n        name: '热力热力',\r\n        source: new SourceVector({\r\n          features: new GeoJSON().readFeatures(HeatData, {\r\n            dataProjection: \"EPSG:4326\",\r\n            featureProjection: \"EPSG:4326\"\r\n          })\r\n        }),\r\n        radius: 10, // 半径大小\r\n        blur: 10, // 模糊\r\n        gradient: [\"#00f\", \"#0ff\", \"#0f0\", \"#ff0\", \"#f00\"], // 热力图颜色（可以不设置）\r\n      })\r\n    }\r\n  },\r\n  methods: {\r\n\r\n    // 初始化地图\r\n    initMap() {\r\n      let raster = new Tile({\r\n        source: new Stamen({\r\n          layer: 'toner'\r\n        })\r\n      })\r\n\r\n      this.map = new Map({\r\n        target: this.$refs.map,\r\n        layers: [raster, this.vector],\r\n        view: new View({\r\n          center: [20.042007, -35.349998],\r\n          zoom: 19\r\n        })\r\n      })\r\n    },\r\n\r\n    // 修改半径大小\r\n    changeRadius() {\r\n      this.vector.setRadius(parseInt(this.radius, 10));\r\n    },\r\n\r\n    // 修改模糊半径\r\n    changeBlur() {\r\n      this.vector.setBlur(parseInt(this.blur, 10))\r\n    },\r\n\r\n    getHeatName() {\r\n      let layers = this.map.getLayers()\r\n      for (var i = 0; i < layers.getLength(); i++) {\r\n        // console.log(layers.item(i))\r\n        console.log('图层名：', layers.item(i).get('name'))\r\n      }\r\n    }\r\n  },\r\n  mounted() {\r\n    this.initMap();\r\n  }\r\n}\r\n</script>\r\n \r\n<style lang=\"scss\" scoped>\r\n\r\n</style>","import mod from \"-!../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./heatmap.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../node_modules/thread-loader/dist/cjs.js!../../../node_modules/babel-loader/lib/index.js!../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./heatmap.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./heatmap.vue?vue&type=template&id=21bb09b7&scoped=true&\"\nimport script from \"./heatmap.vue?vue&type=script&lang=js&\"\nexport * from \"./heatmap.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"21bb09b7\",\n  null\n  \n)\n\nexport default component.exports"],"sourceRoot":""}